/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import * as api from '@opentelemetry/api';
import { isWrapped } from '@opentelemetry/core';
import * as shimmer from 'shimmer';
import { AttributeNames } from './enums/AttributeNames';
import * as React from 'react';
import { VERSION } from './version';
/**
 * This class is the base component for a React component with lifecycle instrumentation
 */
var BaseOpenTelemetryComponent = /** @class */ (function (_super) {
    __extends(BaseOpenTelemetryComponent, _super);
    /**
     * @param props Props of the React component
     */
    function BaseOpenTelemetryComponent(props) {
        var _this = _super.call(this, props) || this;
        _this.component = 'react-load';
        _this.moduleName = _this.component;
        _this._parentSpanMap = new WeakMap();
        _this.patch();
        return _this;
    }
    /**
     * Sets the tracer for all components being instrumented
     * @param name Name of tracer
     * @param version Version of tracer, this is optional. When not provided it will use the latest.
     */
    BaseOpenTelemetryComponent.setTracer = function (name, version) {
        BaseOpenTelemetryComponent._tracer = api.trace.getTracer(name, version ? version : VERSION);
    };
    /**
     * Sets the logger for all components being instrumented
     * @param logger
     */
    BaseOpenTelemetryComponent.setLogger = function (logger) {
        api.diag.setLogger(logger);
        BaseOpenTelemetryComponent._logger = logger;
    };
    /**
     * Creates a new span as a child of the current parent span.
     * If parent span is undefined, just the child is created.
     * @param react React component currently being instrumented
     * @param name Name of span
     * @param parentSpan parent span
     */
    BaseOpenTelemetryComponent.prototype._createSpanWithParent = function (react, name, parentSpan) {
        return BaseOpenTelemetryComponent._tracer.startSpan(name, {
            attributes: this._getAttributes(react),
        }, parentSpan
            ? api.trace.setSpan(api.context.active(), parentSpan)
            : undefined);
    };
    /**
     * Creates a new span
     * @param react React component currently being instrumented
     * @param name Name of span
     */
    BaseOpenTelemetryComponent.prototype._createSpan = function (react, name) {
        return BaseOpenTelemetryComponent._tracer.startSpan(name, {
            attributes: this._getAttributes(react),
        });
    };
    /**
     * Provides instrumentation for a function
     * @param react React component currently instrumenting.
     * @param spanName Name to set the span of the instrumented function to.
     * @param original Original function currently being wrapped.
     * @parentName Name to set parent span to on error.
     */
    BaseOpenTelemetryComponent.prototype._instrumentFunction = function (react, spanName, parent, original) {
        var span = this._createSpanWithParent(react, spanName, parent);
        var wasError = false;
        try {
            return api.context.with(api.trace.setSpan(api.context.active(), span), function () {
                return original();
            });
        }
        catch (err) {
            span.setAttribute(AttributeNames.REACT_ERROR, err.stack);
            wasError = true;
            throw err;
        }
        finally {
            span.end();
            if (wasError) {
                this._endParentSpan(react);
            }
        }
    };
    /**
     * Ends the current parent span.
     * @param react React component parent span belongs to.
     */
    BaseOpenTelemetryComponent.prototype._endParentSpan = function (react) {
        var parentSpan = this._parentSpanMap.get(react);
        if (parentSpan) {
            parentSpan.end();
            this._parentSpanMap.delete(react);
        }
    };
    /**
     * Returns attributes object for spans
     * @param react React component currently being instrumented
     **/
    BaseOpenTelemetryComponent.prototype._getAttributes = function (react) {
        var _a;
        var state;
        try {
            state = JSON.stringify(react.state);
        }
        catch (_b) {
            state = '{"message": "state could not be turned into string"}';
        }
        return _a = {},
            _a[AttributeNames.LOCATION_URL] = window.location.href,
            _a[AttributeNames.REACT_NAME] = react.constructor.name,
            _a[AttributeNames.REACT_STATE] = state,
            _a;
    };
    /**
     * This function returns a parent span. If the parent doesn't
     * exist, the function creates one
     * @param react React component parent span belongs to.
     */
    BaseOpenTelemetryComponent.prototype._getParentSpan = function (react, parentName) {
        var parentSpan = this._parentSpanMap.get(react);
        if (!parentSpan) {
            var span = this._createSpan(react, parentName);
            this._parentSpanMap.set(react, span);
        }
        return this._parentSpanMap.get(react);
    };
    /**
     * Patches the render lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchRender = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchRender() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // Render is the first method in the mounting flow, if a parent span wasn't created already then we're in the mounting flow
                var parentSpan;
                if (!plugin._parentSpanMap.get(this)) {
                    parentSpan = plugin._getParentSpan(this, AttributeNames.MOUNTING_SPAN);
                }
                else {
                    parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                }
                return plugin._instrumentFunction(this, 'render', parentSpan, function () {
                    return original.apply(_this, args);
                });
            };
        };
    };
    /**
     * Patches the componentDidMount lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchComponentDidMount = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchComponentDidMount() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.MOUNTING_SPAN);
                var apply = plugin._instrumentFunction(this, 'componentDidMount', parentSpan, function () {
                    return original.apply(_this, args);
                });
                plugin._endParentSpan(this);
                return apply;
            };
        };
    };
    /**
     * Patches the setState function
     */
    BaseOpenTelemetryComponent.prototype._patchSetState = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchSetState() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                return plugin._instrumentFunction(this, 'setState()', parentSpan, function () {
                    return original.apply(_this, args);
                });
            };
        };
    };
    /**
     * Patches the forceUpdate function
     */
    BaseOpenTelemetryComponent.prototype._patchForceUpdate = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchForceUpdate() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                return plugin._instrumentFunction(this, 'forceUpdate()', parentSpan, function () {
                    return original.apply(_this, args);
                });
            };
        };
    };
    /**
     * Patches the shouldComponentUpdate lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchShouldComponentUpdate = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchShouldComponentUpdate() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                var apply = plugin._instrumentFunction(this, 'shouldComponentUpdate', parentSpan, function () {
                    return original.apply(_this, args);
                });
                // if shouldComponentUpdate returns false, the component does not get
                // updated and no other lifecycle methods get called
                if (!apply) {
                    plugin._endParentSpan(this);
                }
                return apply;
            };
        };
    };
    /**
     * Patches the shouldComponentUpdate lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchGetSnapshotBeforeUpdate = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchGetSnapshotBeforeUpdate() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                return plugin._instrumentFunction(this, 'getSnapshotBeforeUpdate', parentSpan, function () {
                    return original.apply(_this, args);
                });
            };
        };
    };
    /**
     * Patches the componentDidUpdate lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchComponentDidUpdate = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchComponentDidUpdate() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UPDATING_SPAN);
                var apply = plugin._instrumentFunction(this, 'componentDidUpdate', parentSpan, function () {
                    return original.apply(_this, args);
                });
                plugin._endParentSpan(this);
                return apply;
            };
        };
    };
    /**
     * Patches the componentWillUnmount lifecycle method
     */
    BaseOpenTelemetryComponent.prototype._patchComponentWillUnmount = function () {
        var _this = this;
        return function (original) {
            var plugin = _this;
            return function patchComponentWillUnmount() {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var parentSpan = plugin._getParentSpan(this, AttributeNames.UNMOUNTING_SPAN);
                var apply = plugin._instrumentFunction(this, 'componentWillUnmount', parentSpan, function () {
                    return original.apply(_this, args);
                });
                plugin._endParentSpan(this);
                return apply;
            };
        };
    };
    /**
     * patch function which wraps all the lifecycle methods
     */
    BaseOpenTelemetryComponent.prototype.patch = function () {
        BaseOpenTelemetryComponent._logger.debug('applying patch to', this.moduleName, VERSION);
        if (isWrapped(this.render)) {
            shimmer.unwrap(this, 'render');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method render');
        }
        if (isWrapped(this.componentDidMount)) {
            shimmer.unwrap(this, 'componentDidMount');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method componentDidMount');
        }
        if (isWrapped(this.shouldComponentUpdate)) {
            shimmer.unwrap(this, 'shouldComponentUpdate');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method shouldComponentUpdate');
        }
        if (isWrapped(this.getSnapshotBeforeUpdate)) {
            shimmer.unwrap(this, 'getSnapshotBeforeUpdate');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method getSnapshotBeforeUpdate');
        }
        if (isWrapped(this.setState)) {
            shimmer.unwrap(this, 'setState');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method setState');
        }
        if (isWrapped(this.forceUpdate)) {
            shimmer.unwrap(this, 'forceUpdate');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method forceUpdate');
        }
        if (isWrapped(this.componentDidUpdate)) {
            shimmer.unwrap(this, 'componentDidUpdate');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method componentDidUpdate');
        }
        if (isWrapped(this.componentWillUnmount)) {
            shimmer.unwrap(this, 'componentWillUnmount');
            BaseOpenTelemetryComponent._logger.warn('removing previous patch from method componentWillUnmount');
        }
        // Lifecycle methods must exist when patching, even if not defined in component
        if (!this.render) {
            this.render = function () {
                return null;
            };
        }
        if (!this.componentDidMount) {
            this.componentDidMount = function () {
                return;
            };
        }
        if (!this.shouldComponentUpdate) {
            this.shouldComponentUpdate = function () {
                return true;
            };
        }
        if (!this.getSnapshotBeforeUpdate) {
            this.getSnapshotBeforeUpdate = function () {
                return null;
            };
        }
        if (!this.componentDidUpdate) {
            this.componentDidUpdate = function () {
                return;
            };
        }
        if (!this.componentWillUnmount) {
            this.componentWillUnmount = function () {
                return;
            };
        }
        shimmer.wrap(this, 'render', this._patchRender());
        shimmer.wrap(this, 'componentDidMount', this._patchComponentDidMount());
        shimmer.wrap(this, 'setState', this._patchSetState());
        shimmer.wrap(this, 'forceUpdate', this._patchForceUpdate());
        shimmer.wrap(this, 'shouldComponentUpdate', this._patchShouldComponentUpdate());
        shimmer.wrap(this, 'getSnapshotBeforeUpdate', this._patchGetSnapshotBeforeUpdate());
        shimmer.wrap(this, 'componentDidUpdate', this._patchComponentDidUpdate());
        shimmer.wrap(this, 'componentWillUnmount', this._patchComponentWillUnmount());
    };
    /**
     * unpatch function to unwrap all the lifecycle methods
     */
    BaseOpenTelemetryComponent.prototype.unpatch = function () {
        BaseOpenTelemetryComponent._logger.debug('removing patch from', this.moduleName, VERSION);
        shimmer.unwrap(this, 'render');
        shimmer.unwrap(this, 'componentDidMount');
        shimmer.unwrap(this, 'setState');
        shimmer.unwrap(this, 'forceUpdate');
        shimmer.unwrap(this, 'shouldComponentUpdate');
        shimmer.unwrap(this, 'getSnapshotBeforeUpdate');
        shimmer.unwrap(this, 'componentDidUpdate');
        shimmer.unwrap(this, 'componentWillUnmount');
        this._parentSpanMap = new WeakMap();
    };
    BaseOpenTelemetryComponent._logger = api.diag;
    return BaseOpenTelemetryComponent;
}(React.Component));
export { BaseOpenTelemetryComponent };
//# sourceMappingURL=BaseOpenTelemetryComponent.js.map