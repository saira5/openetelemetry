{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { RandomIdGenerator, sanitizeAttributes, isTracingSuppressed } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\n/**\n * This class represents a basic tracer.\n */\n\nvar Tracer =\n/** @class */\nfunction () {\n  /**\n   * Constructs a new Tracer instance.\n   */\n  function Tracer(instrumentationLibrary, config, _tracerProvider) {\n    this._tracerProvider = _tracerProvider;\n    var localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n\n\n  Tracer.prototype.startSpan = function (name, options, context) {\n    var _a, _b;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (context === void 0) {\n      context = api.context.active();\n    }\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      return api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n    }\n\n    var parentContext = getParent(options, context);\n\n    var spanId = this._idGenerator.generateSpanId();\n\n    var traceId;\n    var traceState;\n    var parentSpanId;\n\n    if (!parentContext || !api.trace.isSpanContextValid(parentContext)) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentContext.traceId;\n      traceState = parentContext.traceState;\n      parentSpanId = parentContext.spanId;\n    }\n\n    var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n    var links = (_b = options.links) !== null && _b !== void 0 ? _b : [];\n    var attributes = sanitizeAttributes(options.attributes); // make sampling decision\n\n    var samplingResult = this._sampler.shouldSample(options.root ? api.trace.setSpanContext(context, api.INVALID_SPAN_CONTEXT) : context, traceId, name, spanKind, attributes, links);\n\n    var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;\n    var spanContext = {\n      traceId: traceId,\n      spanId: spanId,\n      traceFlags: traceFlags,\n      traceState: traceState\n    };\n\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug('Recording is off, propagating context in a non-recording span');\n      return api.trace.wrapSpanContext(spanContext);\n    }\n\n    var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime); // Set default attributes\n\n    span.setAttributes(Object.assign(attributes, samplingResult.attributes));\n    return span;\n  };\n\n  Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n    var opts;\n    var ctx;\n    var fn;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2;\n    } else if (arguments.length === 3) {\n      opts = arg2;\n      fn = arg3;\n    } else {\n      opts = arg2;\n      ctx = arg3;\n      fn = arg4;\n    }\n\n    var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n    var span = this.startSpan(name, opts, parentContext);\n    var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  };\n  /** Returns the active {@link SpanLimits}. */\n\n\n  Tracer.prototype.getSpanLimits = function () {\n    return this._spanLimits;\n  };\n\n  Tracer.prototype.getActiveSpanProcessor = function () {\n    return this._tracerProvider.getActiveSpanProcessor();\n  };\n\n  return Tracer;\n}();\n\nexport { Tracer };\n/**\n * Get the parent to assign to a started span. If options.parent is null,\n * do not assign a parent.\n *\n * @param options span options\n * @param context context to check for parent\n */\n\nfunction getParent(options, context) {\n  if (options.root) return undefined;\n  return api.trace.getSpanContext(context);\n}","map":{"version":3,"sources":["../../src/Tracer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { RandomIdGenerator, sanitizeAttributes, isTracingSuppressed, } from '@opentelemetry/core';\nimport { Span } from './Span';\nimport { mergeConfig } from './utility';\n/**\n * This class represents a basic tracer.\n */\nvar Tracer = /** @class */ (function () {\n    /**\n     * Constructs a new Tracer instance.\n     */\n    function Tracer(instrumentationLibrary, config, _tracerProvider) {\n        this._tracerProvider = _tracerProvider;\n        var localConfig = mergeConfig(config);\n        this._sampler = localConfig.sampler;\n        this._spanLimits = localConfig.spanLimits;\n        this._idGenerator = config.idGenerator || new RandomIdGenerator();\n        this.resource = _tracerProvider.resource;\n        this.instrumentationLibrary = instrumentationLibrary;\n    }\n    /**\n     * Starts a new Span or returns the default NoopSpan based on the sampling\n     * decision.\n     */\n    Tracer.prototype.startSpan = function (name, options, context) {\n        var _a, _b;\n        if (options === void 0) { options = {}; }\n        if (context === void 0) { context = api.context.active(); }\n        if (isTracingSuppressed(context)) {\n            api.diag.debug('Instrumentation suppressed, returning Noop Span');\n            return api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n        }\n        var parentContext = getParent(options, context);\n        var spanId = this._idGenerator.generateSpanId();\n        var traceId;\n        var traceState;\n        var parentSpanId;\n        if (!parentContext || !api.trace.isSpanContextValid(parentContext)) {\n            // New root span.\n            traceId = this._idGenerator.generateTraceId();\n        }\n        else {\n            // New child span.\n            traceId = parentContext.traceId;\n            traceState = parentContext.traceState;\n            parentSpanId = parentContext.spanId;\n        }\n        var spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;\n        var links = (_b = options.links) !== null && _b !== void 0 ? _b : [];\n        var attributes = sanitizeAttributes(options.attributes);\n        // make sampling decision\n        var samplingResult = this._sampler.shouldSample(options.root\n            ? api.trace.setSpanContext(context, api.INVALID_SPAN_CONTEXT)\n            : context, traceId, name, spanKind, attributes, links);\n        var traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n            ? api.TraceFlags.SAMPLED\n            : api.TraceFlags.NONE;\n        var spanContext = { traceId: traceId, spanId: spanId, traceFlags: traceFlags, traceState: traceState };\n        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n            api.diag.debug('Recording is off, propagating context in a non-recording span');\n            return api.trace.wrapSpanContext(spanContext);\n        }\n        var span = new Span(this, context, name, spanContext, spanKind, parentSpanId, links, options.startTime);\n        // Set default attributes\n        span.setAttributes(Object.assign(attributes, samplingResult.attributes));\n        return span;\n    };\n    Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {\n        var opts;\n        var ctx;\n        var fn;\n        if (arguments.length < 2) {\n            return;\n        }\n        else if (arguments.length === 2) {\n            fn = arg2;\n        }\n        else if (arguments.length === 3) {\n            opts = arg2;\n            fn = arg3;\n        }\n        else {\n            opts = arg2;\n            ctx = arg3;\n            fn = arg4;\n        }\n        var parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();\n        var span = this.startSpan(name, opts, parentContext);\n        var contextWithSpanSet = api.trace.setSpan(parentContext, span);\n        return api.context.with(contextWithSpanSet, fn, undefined, span);\n    };\n    /** Returns the active {@link SpanLimits}. */\n    Tracer.prototype.getSpanLimits = function () {\n        return this._spanLimits;\n    };\n    Tracer.prototype.getActiveSpanProcessor = function () {\n        return this._tracerProvider.getActiveSpanProcessor();\n    };\n    return Tracer;\n}());\nexport { Tracer };\n/**\n * Get the parent to assign to a started span. If options.parent is null,\n * do not assign a parent.\n *\n * @param options span options\n * @param context context to check for parent\n */\nfunction getParent(options, context) {\n    if (options.root)\n        return undefined;\n    return api.trace.getSpanContext(context);\n}\n//# sourceMappingURL=Tracer.js.map"]},"metadata":{},"sourceType":"module"}