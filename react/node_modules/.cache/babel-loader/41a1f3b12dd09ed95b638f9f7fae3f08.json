{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\n\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\n\nvar ZoneContextManager =\n/** @class */\nfunction () {\n  function ZoneContextManager() {\n    /**\n     * whether the context manager is enabled or not\n     */\n    this._enabled = false;\n    /**\n     * Helps to create a unique name for the zones - part of zone name\n     */\n\n    this._zoneCounter = 0;\n  }\n  /**\n   * Returns the active context from certain zone name\n   * @param activeZone\n   */\n\n\n  ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n    return activeZone && activeZone.get(ZONE_CONTEXT_KEY) || ROOT_CONTEXT;\n  };\n  /**\n   * @param context A context (span) to be executed within target function\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n\n\n  ZoneContextManager.prototype._bindFunction = function (context, target) {\n    var manager = this;\n\n    var contextWrapper = function contextWrapper() {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return manager.with(context, function () {\n        return target.apply(_this, args);\n      });\n    };\n\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length\n    });\n    return contextWrapper;\n  };\n  /**\n   * @param context A context (span) to be bind to target\n   * @param obj target object on which the listeners will be patched\n   */\n\n\n  ZoneContextManager.prototype._bindListener = function (context, obj) {\n    var target = obj;\n\n    if (target.__ot_listeners !== undefined) {\n      return obj;\n    }\n\n    target.__ot_listeners = {};\n\n    if (typeof target.addEventListener === 'function') {\n      target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n    }\n\n    if (typeof target.removeEventListener === 'function') {\n      target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n    }\n\n    return obj;\n  };\n  /**\n   * Creates a new unique zone name\n   */\n\n\n  ZoneContextManager.prototype._createZoneName = function () {\n    this._zoneCounter++;\n    var random = Math.random();\n    return this._zoneCounter + \"-\" + random;\n  };\n  /**\n   * Creates a new zone\n   * @param zoneName zone name\n   * @param context A context (span) to be bind with Zone\n   */\n\n\n  ZoneContextManager.prototype._createZone = function (zoneName, context) {\n    var _a;\n\n    return Zone.current.fork({\n      name: zoneName,\n      properties: (_a = {}, _a[ZONE_CONTEXT_KEY] = context, _a)\n    });\n  };\n  /**\n   * Returns the active zone\n   */\n\n\n  ZoneContextManager.prototype._getActiveZone = function () {\n    return Zone.current;\n  };\n  /**\n   * Patches addEventListener method\n   * @param target any target that has \"addEventListener\" method\n   * @param original reference to the patched method\n   * @param [context] context to be bind to the listener\n   */\n\n\n  ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n    var contextManager = this;\n    return function (event, listener, opts) {\n      if (target.__ot_listeners === undefined) {\n        target.__ot_listeners = {};\n      }\n\n      var listeners = target.__ot_listeners[event];\n\n      if (listeners === undefined) {\n        listeners = new WeakMap();\n        target.__ot_listeners[event] = listeners;\n      }\n\n      var patchedListener = contextManager.bind(context, listener); // store a weak reference of the user listener to ours\n\n      listeners.set(listener, patchedListener);\n      return original.call(this, event, patchedListener, opts);\n    };\n  };\n  /**\n   * Patches removeEventListener method\n   * @param target any target that has \"removeEventListener\" method\n   * @param original reference to the patched method\n   */\n\n\n  ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n    return function (event, listener) {\n      if (target.__ot_listeners === undefined || target.__ot_listeners[event] === undefined) {\n        return original.call(this, event, listener);\n      }\n\n      var events = target.__ot_listeners[event];\n      var patchedListener = events.get(listener);\n      events.delete(listener);\n      return original.call(this, event, patchedListener || listener);\n    };\n  };\n  /**\n   * Returns the active context\n   */\n\n\n  ZoneContextManager.prototype.active = function () {\n    if (!this._enabled) {\n      return ROOT_CONTEXT;\n    }\n\n    var activeZone = this._getActiveZone();\n\n    var active = this._activeContextFromZone(activeZone);\n\n    if (active) {\n      return active;\n    }\n\n    return ROOT_CONTEXT;\n  };\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n\n\n  ZoneContextManager.prototype.bind = function (context, target) {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    } else if (isListenerObject(target)) {\n      this._bindListener(context, target);\n    }\n\n    return target;\n  };\n  /**\n   * Disable the context manager (clears all the contexts)\n   */\n\n\n  ZoneContextManager.prototype.disable = function () {\n    this._enabled = false;\n    return this;\n  };\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n\n\n  ZoneContextManager.prototype.enable = function () {\n    this._enabled = true;\n    return this;\n  };\n  /**\n   * Calls the callback function [fn] with the provided [context].\n   *     If [context] is undefined then it will use the active context.\n   *     The context will be set as active\n   * @param context A context (span) to be called with provided callback\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n\n\n  ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n    var args = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      args[_i - 3] = arguments[_i];\n    }\n\n    var zoneName = this._createZoneName();\n\n    var newZone = this._createZone(zoneName, context);\n\n    return newZone.run(fn, thisArg, args);\n  };\n\n  return ZoneContextManager;\n}();\n\nexport { ZoneContextManager };","map":{"version":3,"sources":["../../src/ZoneContextManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ROOT_CONTEXT } from '@opentelemetry/api';\nimport { isListenerObject } from './util';\n/* Key name to be used to save a context reference in Zone */\nvar ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';\n/**\n * ZoneContextManager\n * This module provides an easy functionality for tracing action between asynchronous operations in web.\n * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.\n * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.\n * It stores the information about context in zone. Each Context will have always new Zone;\n * It also supports binding a certain Span to a target that has \"addEventListener\" and \"removeEventListener\".\n * When this happens a new zone is being created and the provided Span is being assigned to this zone.\n */\nvar ZoneContextManager = /** @class */ (function () {\n    function ZoneContextManager() {\n        /**\n         * whether the context manager is enabled or not\n         */\n        this._enabled = false;\n        /**\n         * Helps to create a unique name for the zones - part of zone name\n         */\n        this._zoneCounter = 0;\n    }\n    /**\n     * Returns the active context from certain zone name\n     * @param activeZone\n     */\n    ZoneContextManager.prototype._activeContextFromZone = function (activeZone) {\n        return (activeZone && activeZone.get(ZONE_CONTEXT_KEY)) || ROOT_CONTEXT;\n    };\n    /**\n     * @param context A context (span) to be executed within target function\n     * @param target Function to be executed within the context\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    ZoneContextManager.prototype._bindFunction = function (context, target) {\n        var manager = this;\n        var contextWrapper = function () {\n            var _this = this;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.with(context, function () { return target.apply(_this, args); });\n        };\n        Object.defineProperty(contextWrapper, 'length', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: target.length,\n        });\n        return contextWrapper;\n    };\n    /**\n     * @param context A context (span) to be bind to target\n     * @param obj target object on which the listeners will be patched\n     */\n    ZoneContextManager.prototype._bindListener = function (context, obj) {\n        var target = obj;\n        if (target.__ot_listeners !== undefined) {\n            return obj;\n        }\n        target.__ot_listeners = {};\n        if (typeof target.addEventListener === 'function') {\n            target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);\n        }\n        if (typeof target.removeEventListener === 'function') {\n            target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);\n        }\n        return obj;\n    };\n    /**\n     * Creates a new unique zone name\n     */\n    ZoneContextManager.prototype._createZoneName = function () {\n        this._zoneCounter++;\n        var random = Math.random();\n        return this._zoneCounter + \"-\" + random;\n    };\n    /**\n     * Creates a new zone\n     * @param zoneName zone name\n     * @param context A context (span) to be bind with Zone\n     */\n    ZoneContextManager.prototype._createZone = function (zoneName, context) {\n        var _a;\n        return Zone.current.fork({\n            name: zoneName,\n            properties: (_a = {},\n                _a[ZONE_CONTEXT_KEY] = context,\n                _a),\n        });\n    };\n    /**\n     * Returns the active zone\n     */\n    ZoneContextManager.prototype._getActiveZone = function () {\n        return Zone.current;\n    };\n    /**\n     * Patches addEventListener method\n     * @param target any target that has \"addEventListener\" method\n     * @param original reference to the patched method\n     * @param [context] context to be bind to the listener\n     */\n    ZoneContextManager.prototype._patchAddEventListener = function (target, original, context) {\n        var contextManager = this;\n        return function (event, listener, opts) {\n            if (target.__ot_listeners === undefined) {\n                target.__ot_listeners = {};\n            }\n            var listeners = target.__ot_listeners[event];\n            if (listeners === undefined) {\n                listeners = new WeakMap();\n                target.__ot_listeners[event] = listeners;\n            }\n            var patchedListener = contextManager.bind(context, listener);\n            // store a weak reference of the user listener to ours\n            listeners.set(listener, patchedListener);\n            return original.call(this, event, patchedListener, opts);\n        };\n    };\n    /**\n     * Patches removeEventListener method\n     * @param target any target that has \"removeEventListener\" method\n     * @param original reference to the patched method\n     */\n    ZoneContextManager.prototype._patchRemoveEventListener = function (target, original) {\n        return function (event, listener) {\n            if (target.__ot_listeners === undefined ||\n                target.__ot_listeners[event] === undefined) {\n                return original.call(this, event, listener);\n            }\n            var events = target.__ot_listeners[event];\n            var patchedListener = events.get(listener);\n            events.delete(listener);\n            return original.call(this, event, patchedListener || listener);\n        };\n    };\n    /**\n     * Returns the active context\n     */\n    ZoneContextManager.prototype.active = function () {\n        if (!this._enabled) {\n            return ROOT_CONTEXT;\n        }\n        var activeZone = this._getActiveZone();\n        var active = this._activeContextFromZone(activeZone);\n        if (active) {\n            return active;\n        }\n        return ROOT_CONTEXT;\n    };\n    /**\n     * Binds a the certain context or the active one to the target function and then returns the target\n     * @param context A context (span) to be bind to target\n     * @param target a function or event emitter. When target or one of its callbacks is called,\n     *  the provided context will be used as the active context for the duration of the call.\n     */\n    ZoneContextManager.prototype.bind = function (context, target) {\n        // if no specific context to propagate is given, we use the current one\n        if (context === undefined) {\n            context = this.active();\n        }\n        if (typeof target === 'function') {\n            return this._bindFunction(context, target);\n        }\n        else if (isListenerObject(target)) {\n            this._bindListener(context, target);\n        }\n        return target;\n    };\n    /**\n     * Disable the context manager (clears all the contexts)\n     */\n    ZoneContextManager.prototype.disable = function () {\n        this._enabled = false;\n        return this;\n    };\n    /**\n     * Enables the context manager and creates a default(root) context\n     */\n    ZoneContextManager.prototype.enable = function () {\n        this._enabled = true;\n        return this;\n    };\n    /**\n     * Calls the callback function [fn] with the provided [context].\n     *     If [context] is undefined then it will use the active context.\n     *     The context will be set as active\n     * @param context A context (span) to be called with provided callback\n     * @param fn Callback function\n     * @param thisArg optional receiver to be used for calling fn\n     * @param args optional arguments forwarded to fn\n     */\n    ZoneContextManager.prototype.with = function (context, fn, thisArg) {\n        var args = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            args[_i - 3] = arguments[_i];\n        }\n        var zoneName = this._createZoneName();\n        var newZone = this._createZone(zoneName, context);\n        return newZone.run(fn, thisArg, args);\n    };\n    return ZoneContextManager;\n}());\nexport { ZoneContextManager };\n//# sourceMappingURL=ZoneContextManager.js.map"]},"metadata":{},"sourceType":"module"}