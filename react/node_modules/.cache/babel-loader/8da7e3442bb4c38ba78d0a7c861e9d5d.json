{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from '../types';\nimport { hrTime } from '@opentelemetry/core';\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\n\nvar HistogramAggregator =\n/** @class */\nfunction () {\n  function HistogramAggregator(boundaries) {\n    this.kind = AggregatorKind.HISTOGRAM;\n\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    } // we need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n\n\n    this._boundaries = boundaries.sort(function (a, b) {\n      return a - b;\n    });\n    this._current = this._newEmptyCheckpoint();\n    this._lastUpdateTime = hrTime();\n  }\n\n  HistogramAggregator.prototype.update = function (value) {\n    this._lastUpdateTime = hrTime();\n    this._current.count += 1;\n    this._current.sum += value;\n\n    for (var i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    } // value is above all observed boundaries\n\n\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  };\n\n  HistogramAggregator.prototype.toPoint = function () {\n    return {\n      value: this._current,\n      timestamp: this._lastUpdateTime\n    };\n  };\n\n  HistogramAggregator.prototype._newEmptyCheckpoint = function () {\n    return {\n      buckets: {\n        boundaries: this._boundaries,\n        counts: this._boundaries.map(function () {\n          return 0;\n        }).concat([0])\n      },\n      sum: 0,\n      count: 0\n    };\n  };\n\n  return HistogramAggregator;\n}();\n\nexport { HistogramAggregator };","map":{"version":3,"sources":["../../../../src/export/aggregators/Histogram.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,SAIE,cAJF,QAKO,UALP;AAOA,SAAS,MAAT,QAAuB,qBAAvB;AAEA;;;AAGG;;AACH,IAAA,mBAAA;AAAA;AAAA,YAAA;EAME,SAAA,mBAAA,CAAY,UAAZ,EAAgC;IALzB,KAAA,IAAA,GAAiC,cAAc,CAAC,SAAhD;;IAML,IAAI,UAAU,KAAK,SAAf,IAA4B,UAAU,CAAC,MAAX,KAAsB,CAAtD,EAAyD;MACvD,MAAM,IAAI,KAAJ,CAAU,wDAAV,CAAN;IACD,CAH6B,CAI9B;IACA;;;IACA,KAAK,WAAL,GAAmB,UAAU,CAAC,IAAX,CAAgB,UAAC,CAAD,EAAI,CAAJ,EAAK;MAAK,OAAA,CAAC,GAAD,CAAA;IAAK,CAA/B,CAAnB;IACA,KAAK,QAAL,GAAgB,KAAK,mBAAL,EAAhB;IACA,KAAK,eAAL,GAAuB,MAAM,EAA7B;EACD;;EAED,mBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,KAAP,EAAoB;IAClB,KAAK,eAAL,GAAuB,MAAM,EAA7B;IACA,KAAK,QAAL,CAAc,KAAd,IAAuB,CAAvB;IACA,KAAK,QAAL,CAAc,GAAd,IAAqB,KAArB;;IAEA,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,WAAL,CAAiB,MAArC,EAA6C,CAAC,EAA9C,EAAkD;MAChD,IAAI,KAAK,GAAG,KAAK,WAAL,CAAiB,CAAjB,CAAZ,EAAiC;QAC/B,KAAK,QAAL,CAAc,OAAd,CAAsB,MAAtB,CAA6B,CAA7B,KAAmC,CAAnC;QACA;MACD;IACF,CAViB,CAWlB;;;IACA,KAAK,QAAL,CAAc,OAAd,CAAsB,MAAtB,CAA6B,KAAK,WAAL,CAAiB,MAA9C,KAAyD,CAAzD;EACD,CAbD;;EAeA,mBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;IACE,OAAO;MACL,KAAK,EAAE,KAAK,QADP;MAEL,SAAS,EAAE,KAAK;IAFX,CAAP;EAID,CALD;;EAOQ,mBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,YAAA;IACE,OAAO;MACL,OAAO,EAAE;QACP,UAAU,EAAE,KAAK,WADV;QAEP,MAAM,EAAE,KAAK,WAAL,CAAiB,GAAjB,CAAqB,YAAA;UAAM,OAAA,CAAA;QAAC,CAA5B,EAA8B,MAA9B,CAAqC,CAAC,CAAD,CAArC;MAFD,CADJ;MAKL,GAAG,EAAE,CALA;MAML,KAAK,EAAE;IANF,CAAP;EAQD,CATO;;EAUV,OAAA,mBAAA;AAAC,CAjDD,EAAA","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind, } from '../types';\nimport { hrTime } from '@opentelemetry/core';\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nvar HistogramAggregator = /** @class */ (function () {\n    function HistogramAggregator(boundaries) {\n        this.kind = AggregatorKind.HISTOGRAM;\n        if (boundaries === undefined || boundaries.length === 0) {\n            throw new Error('HistogramAggregator should be created with boundaries.');\n        }\n        // we need to an ordered set to be able to correctly compute count for each\n        // boundary since we'll iterate on each in order.\n        this._boundaries = boundaries.sort(function (a, b) { return a - b; });\n        this._current = this._newEmptyCheckpoint();\n        this._lastUpdateTime = hrTime();\n    }\n    HistogramAggregator.prototype.update = function (value) {\n        this._lastUpdateTime = hrTime();\n        this._current.count += 1;\n        this._current.sum += value;\n        for (var i = 0; i < this._boundaries.length; i++) {\n            if (value < this._boundaries[i]) {\n                this._current.buckets.counts[i] += 1;\n                return;\n            }\n        }\n        // value is above all observed boundaries\n        this._current.buckets.counts[this._boundaries.length] += 1;\n    };\n    HistogramAggregator.prototype.toPoint = function () {\n        return {\n            value: this._current,\n            timestamp: this._lastUpdateTime,\n        };\n    };\n    HistogramAggregator.prototype._newEmptyCheckpoint = function () {\n        return {\n            buckets: {\n                boundaries: this._boundaries,\n                counts: this._boundaries.map(function () { return 0; }).concat([0]),\n            },\n            sum: 0,\n            count: 0,\n        };\n    };\n    return HistogramAggregator;\n}());\nexport { HistogramAggregator };\n//# sourceMappingURL=Histogram.js.map"]},"metadata":{},"sourceType":"module"}