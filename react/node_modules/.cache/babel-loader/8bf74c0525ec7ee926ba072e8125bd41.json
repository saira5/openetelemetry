{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { isAttributeValue, hrTime, hrTimeDuration, isTimeInput, timeInputToHrTime } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\n\nvar Span =\n/** @class */\nfunction () {\n  /** Constructs a new Span instance. */\n  function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime) {\n    if (links === void 0) {\n      links = [];\n    }\n\n    if (startTime === void 0) {\n      startTime = hrTime();\n    }\n\n    this.attributes = {};\n    this.links = [];\n    this.events = [];\n    this.status = {\n      code: api.SpanStatusCode.UNSET\n    };\n    this.endTime = [0, 0];\n    this._ended = false;\n    this._duration = [-1, -1];\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    this.startTime = timeInputToHrTime(startTime);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n\n    this._spanProcessor.onStart(this, context);\n  }\n\n  Span.prototype.spanContext = function () {\n    return this._spanContext;\n  };\n\n  Span.prototype.setAttribute = function (key, value) {\n    if (value == null || this._isSpanEnded()) return this;\n\n    if (key.length === 0) {\n      api.diag.warn(\"Invalid attribute key: \" + key);\n      return this;\n    }\n\n    if (!isAttributeValue(value)) {\n      api.diag.warn(\"Invalid attribute value set for key: \" + key);\n      return this;\n    }\n\n    if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n      return this;\n    }\n\n    this.attributes[key] = value;\n    return this;\n  };\n\n  Span.prototype.setAttributes = function (attributes) {\n    for (var _i = 0, _a = Object.entries(attributes); _i < _a.length; _i++) {\n      var _b = _a[_i],\n          k = _b[0],\n          v = _b[1];\n      this.setAttribute(k, v);\n    }\n\n    return this;\n  };\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [startTime] Specified start time for the event\n   */\n\n\n  Span.prototype.addEvent = function (name, attributesOrStartTime, startTime) {\n    if (this._isSpanEnded()) return this;\n\n    if (this.events.length >= this._spanLimits.eventCountLimit) {\n      api.diag.warn('Dropping extra events.');\n      this.events.shift();\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (typeof startTime === 'undefined') {\n        startTime = attributesOrStartTime;\n      }\n\n      attributesOrStartTime = undefined;\n    }\n\n    if (typeof startTime === 'undefined') {\n      startTime = hrTime();\n    }\n\n    this.events.push({\n      name: name,\n      attributes: attributesOrStartTime,\n      time: timeInputToHrTime(startTime)\n    });\n    return this;\n  };\n\n  Span.prototype.setStatus = function (status) {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  };\n\n  Span.prototype.updateName = function (name) {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  };\n\n  Span.prototype.end = function (endTime) {\n    if (endTime === void 0) {\n      endTime = hrTime();\n    }\n\n    if (this._isSpanEnded()) {\n      api.diag.error('You can only call end() on a span once.');\n      return;\n    }\n\n    this._ended = true;\n    this.endTime = timeInputToHrTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      api.diag.warn('Inconsistent start and end time, startTime > endTime', this.startTime, this.endTime);\n    }\n\n    this._spanProcessor.onEnd(this);\n  };\n\n  Span.prototype.isRecording = function () {\n    return this._ended === false;\n  };\n\n  Span.prototype.recordException = function (exception, time) {\n    if (time === void 0) {\n      time = hrTime();\n    }\n\n    var attributes = {};\n\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    } // these are minimum requirements from spec\n\n\n    if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      api.diag.warn(\"Failed to record an exception \" + exception);\n    }\n  };\n\n  Object.defineProperty(Span.prototype, \"duration\", {\n    get: function get() {\n      return this._duration;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Span.prototype, \"ended\", {\n    get: function get() {\n      return this._ended;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Span.prototype._isSpanEnded = function () {\n    if (this._ended) {\n      api.diag.warn('Can not execute the operation on ended Span {traceId: %s, spanId: %s}', this._spanContext.traceId, this._spanContext.spanId);\n    }\n\n    return this._ended;\n  };\n\n  return Span;\n}();\n\nexport { Span };","map":{"version":3,"sources":["../../src/Span.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { isAttributeValue, hrTime, hrTimeDuration, isTimeInput, timeInputToHrTime, } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\n/**\n * This class represents a span.\n */\nvar Span = /** @class */ (function () {\n    /** Constructs a new Span instance. */\n    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime) {\n        if (links === void 0) { links = []; }\n        if (startTime === void 0) { startTime = hrTime(); }\n        this.attributes = {};\n        this.links = [];\n        this.events = [];\n        this.status = {\n            code: api.SpanStatusCode.UNSET,\n        };\n        this.endTime = [0, 0];\n        this._ended = false;\n        this._duration = [-1, -1];\n        this.name = spanName;\n        this._spanContext = spanContext;\n        this.parentSpanId = parentSpanId;\n        this.kind = kind;\n        this.links = links;\n        this.startTime = timeInputToHrTime(startTime);\n        this.resource = parentTracer.resource;\n        this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n        this._spanLimits = parentTracer.getSpanLimits();\n        this._spanProcessor = parentTracer.getActiveSpanProcessor();\n        this._spanProcessor.onStart(this, context);\n    }\n    Span.prototype.spanContext = function () {\n        return this._spanContext;\n    };\n    Span.prototype.setAttribute = function (key, value) {\n        if (value == null || this._isSpanEnded())\n            return this;\n        if (key.length === 0) {\n            api.diag.warn(\"Invalid attribute key: \" + key);\n            return this;\n        }\n        if (!isAttributeValue(value)) {\n            api.diag.warn(\"Invalid attribute value set for key: \" + key);\n            return this;\n        }\n        if (Object.keys(this.attributes).length >=\n            this._spanLimits.attributeCountLimit &&\n            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {\n            return this;\n        }\n        this.attributes[key] = value;\n        return this;\n    };\n    Span.prototype.setAttributes = function (attributes) {\n        for (var _i = 0, _a = Object.entries(attributes); _i < _a.length; _i++) {\n            var _b = _a[_i], k = _b[0], v = _b[1];\n            this.setAttribute(k, v);\n        }\n        return this;\n    };\n    /**\n     *\n     * @param name Span Name\n     * @param [attributesOrStartTime] Span attributes or start time\n     *     if type is {@type TimeInput} and 3rd param is undefined\n     * @param [startTime] Specified start time for the event\n     */\n    Span.prototype.addEvent = function (name, attributesOrStartTime, startTime) {\n        if (this._isSpanEnded())\n            return this;\n        if (this.events.length >= this._spanLimits.eventCountLimit) {\n            api.diag.warn('Dropping extra events.');\n            this.events.shift();\n        }\n        if (isTimeInput(attributesOrStartTime)) {\n            if (typeof startTime === 'undefined') {\n                startTime = attributesOrStartTime;\n            }\n            attributesOrStartTime = undefined;\n        }\n        if (typeof startTime === 'undefined') {\n            startTime = hrTime();\n        }\n        this.events.push({\n            name: name,\n            attributes: attributesOrStartTime,\n            time: timeInputToHrTime(startTime),\n        });\n        return this;\n    };\n    Span.prototype.setStatus = function (status) {\n        if (this._isSpanEnded())\n            return this;\n        this.status = status;\n        return this;\n    };\n    Span.prototype.updateName = function (name) {\n        if (this._isSpanEnded())\n            return this;\n        this.name = name;\n        return this;\n    };\n    Span.prototype.end = function (endTime) {\n        if (endTime === void 0) { endTime = hrTime(); }\n        if (this._isSpanEnded()) {\n            api.diag.error('You can only call end() on a span once.');\n            return;\n        }\n        this._ended = true;\n        this.endTime = timeInputToHrTime(endTime);\n        this._duration = hrTimeDuration(this.startTime, this.endTime);\n        if (this._duration[0] < 0) {\n            api.diag.warn('Inconsistent start and end time, startTime > endTime', this.startTime, this.endTime);\n        }\n        this._spanProcessor.onEnd(this);\n    };\n    Span.prototype.isRecording = function () {\n        return this._ended === false;\n    };\n    Span.prototype.recordException = function (exception, time) {\n        if (time === void 0) { time = hrTime(); }\n        var attributes = {};\n        if (typeof exception === 'string') {\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n        }\n        else if (exception) {\n            if (exception.code) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();\n            }\n            else if (exception.name) {\n                attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n            }\n            if (exception.message) {\n                attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n            }\n            if (exception.stack) {\n                attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n            }\n        }\n        // these are minimum requirements from spec\n        if (attributes[SemanticAttributes.EXCEPTION_TYPE] ||\n            attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {\n            this.addEvent(ExceptionEventName, attributes, time);\n        }\n        else {\n            api.diag.warn(\"Failed to record an exception \" + exception);\n        }\n    };\n    Object.defineProperty(Span.prototype, \"duration\", {\n        get: function () {\n            return this._duration;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Span.prototype, \"ended\", {\n        get: function () {\n            return this._ended;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Span.prototype._isSpanEnded = function () {\n        if (this._ended) {\n            api.diag.warn('Can not execute the operation on ended Span {traceId: %s, spanId: %s}', this._spanContext.traceId, this._spanContext.spanId);\n        }\n        return this._ended;\n    };\n    return Span;\n}());\nexport { Span };\n//# sourceMappingURL=Span.js.map"]},"metadata":{},"sourceType":"module"}