{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PerformanceTimingNames as PTN } from './enums/PerformanceTimingNames';\nimport { hrTimeToNanoseconds, timeInputToHrTime, urlMatches } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions'; // Used to normalize relative URLs\n\nvar a;\nexport function getUrlNormalizingAnchor() {\n  if (!a) {\n    a = document.createElement('a');\n  }\n\n  return a;\n}\n/**\n * Helper function to be able to use enum as typed key in type and in interface when using forEach\n * @param obj\n * @param key\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function hasKey(obj, key) {\n  return key in obj;\n}\n/**\n * Helper function for starting an event on span based on {@link PerformanceEntries}\n * @param span\n * @param performanceName name of performance entry for time start\n * @param entries\n */\n\nexport function addSpanNetworkEvent(span, performanceName, entries) {\n  if (hasKey(entries, performanceName) && typeof entries[performanceName] === 'number') {\n    span.addEvent(performanceName, entries[performanceName]);\n    return span;\n  }\n\n  return undefined;\n}\n/**\n * Helper function for adding network events\n * @param span\n * @param resource\n */\n\nexport function addSpanNetworkEvents(span, resource) {\n  addSpanNetworkEvent(span, PTN.FETCH_START, resource);\n  addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_START, resource);\n  addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_END, resource);\n  addSpanNetworkEvent(span, PTN.CONNECT_START, resource);\n  addSpanNetworkEvent(span, PTN.SECURE_CONNECTION_START, resource);\n  addSpanNetworkEvent(span, PTN.CONNECT_END, resource);\n  addSpanNetworkEvent(span, PTN.REQUEST_START, resource);\n  addSpanNetworkEvent(span, PTN.RESPONSE_START, resource);\n  addSpanNetworkEvent(span, PTN.RESPONSE_END, resource);\n  var encodedLength = resource[PTN.ENCODED_BODY_SIZE];\n\n  if (encodedLength !== undefined) {\n    span.setAttribute(SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);\n  }\n\n  var decodedLength = resource[PTN.DECODED_BODY_SIZE]; // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)\n\n  if (decodedLength !== undefined && encodedLength !== decodedLength) {\n    span.setAttribute(SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, decodedLength);\n  }\n}\n/**\n * sort resources by startTime\n * @param filteredResources\n */\n\nexport function sortResources(filteredResources) {\n  return filteredResources.slice().sort(function (a, b) {\n    var valueA = a[PTN.FETCH_START];\n    var valueB = b[PTN.FETCH_START];\n\n    if (valueA > valueB) {\n      return 1;\n    } else if (valueA < valueB) {\n      return -1;\n    }\n\n    return 0;\n  });\n}\n/**\n * Get closest performance resource ignoring the resources that have been\n * already used.\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n * @param initiatorType\n */\n\nexport function getResource(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {\n  if (ignoredResources === void 0) {\n    ignoredResources = new WeakSet();\n  } // de-relativize the URL before usage (does no harm to absolute URLs)\n\n\n  var urlNormalizingAnchor = getUrlNormalizingAnchor();\n  urlNormalizingAnchor.href = spanUrl;\n  spanUrl = urlNormalizingAnchor.href;\n  var filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);\n\n  if (filteredResources.length === 0) {\n    return {\n      mainRequest: undefined\n    };\n  }\n\n  if (filteredResources.length === 1) {\n    return {\n      mainRequest: filteredResources[0]\n    };\n  }\n\n  var sorted = sortResources(filteredResources);\n  var parsedSpanUrl = parseUrl(spanUrl);\n\n  if (parsedSpanUrl.origin !== window.location.origin && sorted.length > 1) {\n    var corsPreFlightRequest = sorted[0];\n    var mainRequest = findMainRequest(sorted, corsPreFlightRequest[PTN.RESPONSE_END], endTimeHR);\n    var responseEnd = corsPreFlightRequest[PTN.RESPONSE_END];\n    var fetchStart = mainRequest[PTN.FETCH_START]; // no corsPreFlightRequest\n\n    if (fetchStart < responseEnd) {\n      mainRequest = corsPreFlightRequest;\n      corsPreFlightRequest = undefined;\n    }\n\n    return {\n      corsPreFlightRequest: corsPreFlightRequest,\n      mainRequest: mainRequest\n    };\n  } else {\n    return {\n      mainRequest: filteredResources[0]\n    };\n  }\n}\n/**\n * Will find the main request skipping the cors pre flight requests\n * @param resources\n * @param corsPreFlightRequestEndTime\n * @param spanEndTimeHR\n */\n\nfunction findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {\n  var spanEndTime = hrTimeToNanoseconds(spanEndTimeHR);\n  var minTime = hrTimeToNanoseconds(timeInputToHrTime(corsPreFlightRequestEndTime));\n  var mainRequest = resources[1];\n  var bestGap;\n  var length = resources.length;\n\n  for (var i = 1; i < length; i++) {\n    var resource = resources[i];\n    var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.FETCH_START]));\n    var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.RESPONSE_END]));\n    var currentGap = spanEndTime - resourceEndTime;\n\n    if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {\n      bestGap = currentGap;\n      mainRequest = resource;\n    }\n  }\n\n  return mainRequest;\n}\n/**\n * Filter all resources that has started and finished according to span start time and end time.\n *     It will return the closest resource to a start time\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n */\n\n\nfunction filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {\n  var startTime = hrTimeToNanoseconds(startTimeHR);\n  var endTime = hrTimeToNanoseconds(endTimeHR);\n  var filteredResources = resources.filter(function (resource) {\n    var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.FETCH_START]));\n    var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.RESPONSE_END]));\n    return resource.initiatorType.toLowerCase() === (initiatorType || 'xmlhttprequest') && resource.name === spanUrl && resourceStartTime >= startTime && resourceEndTime <= endTime;\n  });\n\n  if (filteredResources.length > 0) {\n    filteredResources = filteredResources.filter(function (resource) {\n      return !ignoredResources.has(resource);\n    });\n  }\n\n  return filteredResources;\n}\n/**\n * Parses url using anchor element\n * @param url\n */\n\n\nexport function parseUrl(url) {\n  var a = document.createElement('a');\n  a.href = url;\n  return a;\n}\n/**\n * Get element XPath\n * @param target - target element\n * @param optimised - when id attribute of element is present the xpath can be\n * simplified to contain id\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function getElementXPath(target, optimised) {\n  if (target.nodeType === Node.DOCUMENT_NODE) {\n    return '/';\n  }\n\n  var targetValue = getNodeValue(target, optimised);\n\n  if (optimised && targetValue.indexOf('@id') > 0) {\n    return targetValue;\n  }\n\n  var xpath = '';\n\n  if (target.parentNode) {\n    xpath += getElementXPath(target.parentNode, false);\n  }\n\n  xpath += targetValue;\n  return xpath;\n}\n/**\n * get node index within the siblings\n * @param target\n */\n\nfunction getNodeIndex(target) {\n  if (!target.parentNode) {\n    return 0;\n  }\n\n  var allowedTypes = [target.nodeType];\n\n  if (target.nodeType === Node.CDATA_SECTION_NODE) {\n    allowedTypes.push(Node.TEXT_NODE);\n  }\n\n  var elements = Array.from(target.parentNode.childNodes);\n  elements = elements.filter(function (element) {\n    var localName = element.localName;\n    return allowedTypes.indexOf(element.nodeType) >= 0 && localName === target.localName;\n  });\n\n  if (elements.length >= 1) {\n    return elements.indexOf(target) + 1; // xpath starts from 1\n  } // if there are no other similar child xpath doesn't need index\n\n\n  return 0;\n}\n/**\n * get node value for xpath\n * @param target\n * @param optimised\n */\n\n\nfunction getNodeValue(target, optimised) {\n  var nodeType = target.nodeType;\n  var index = getNodeIndex(target);\n  var nodeValue = '';\n\n  if (nodeType === Node.ELEMENT_NODE) {\n    var id = target.getAttribute('id');\n\n    if (optimised && id) {\n      return \"//*[@id=\\\"\" + id + \"\\\"]\";\n    }\n\n    nodeValue = target.localName;\n  } else if (nodeType === Node.TEXT_NODE || nodeType === Node.CDATA_SECTION_NODE) {\n    nodeValue = 'text()';\n  } else if (nodeType === Node.COMMENT_NODE) {\n    nodeValue = 'comment()';\n  } else {\n    return '';\n  } // if index is 1 it can be omitted in xpath\n\n\n  if (nodeValue && index > 1) {\n    return \"/\" + nodeValue + \"[\" + index + \"]\";\n  }\n\n  return \"/\" + nodeValue;\n}\n/**\n * Checks if trace headers should be propagated\n * @param spanUrl\n * @private\n */\n\n\nexport function shouldPropagateTraceHeaders(spanUrl, propagateTraceHeaderCorsUrls) {\n  var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];\n\n  if (typeof propagateTraceHeaderUrls === 'string' || propagateTraceHeaderUrls instanceof RegExp) {\n    propagateTraceHeaderUrls = [propagateTraceHeaderUrls];\n  }\n\n  var parsedSpanUrl = parseUrl(spanUrl);\n\n  if (parsedSpanUrl.origin === window.location.origin) {\n    return true;\n  } else {\n    return propagateTraceHeaderUrls.some(function (propagateTraceHeaderUrl) {\n      return urlMatches(spanUrl, propagateTraceHeaderUrl);\n    });\n  }\n}","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PerformanceTimingNames as PTN } from './enums/PerformanceTimingNames';\nimport { hrTimeToNanoseconds, timeInputToHrTime, urlMatches, } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\n// Used to normalize relative URLs\nvar a;\nexport function getUrlNormalizingAnchor() {\n    if (!a) {\n        a = document.createElement('a');\n    }\n    return a;\n}\n/**\n * Helper function to be able to use enum as typed key in type and in interface when using forEach\n * @param obj\n * @param key\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function hasKey(obj, key) {\n    return key in obj;\n}\n/**\n * Helper function for starting an event on span based on {@link PerformanceEntries}\n * @param span\n * @param performanceName name of performance entry for time start\n * @param entries\n */\nexport function addSpanNetworkEvent(span, performanceName, entries) {\n    if (hasKey(entries, performanceName) &&\n        typeof entries[performanceName] === 'number') {\n        span.addEvent(performanceName, entries[performanceName]);\n        return span;\n    }\n    return undefined;\n}\n/**\n * Helper function for adding network events\n * @param span\n * @param resource\n */\nexport function addSpanNetworkEvents(span, resource) {\n    addSpanNetworkEvent(span, PTN.FETCH_START, resource);\n    addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_START, resource);\n    addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_END, resource);\n    addSpanNetworkEvent(span, PTN.CONNECT_START, resource);\n    addSpanNetworkEvent(span, PTN.SECURE_CONNECTION_START, resource);\n    addSpanNetworkEvent(span, PTN.CONNECT_END, resource);\n    addSpanNetworkEvent(span, PTN.REQUEST_START, resource);\n    addSpanNetworkEvent(span, PTN.RESPONSE_START, resource);\n    addSpanNetworkEvent(span, PTN.RESPONSE_END, resource);\n    var encodedLength = resource[PTN.ENCODED_BODY_SIZE];\n    if (encodedLength !== undefined) {\n        span.setAttribute(SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);\n    }\n    var decodedLength = resource[PTN.DECODED_BODY_SIZE];\n    // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)\n    if (decodedLength !== undefined && encodedLength !== decodedLength) {\n        span.setAttribute(SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, decodedLength);\n    }\n}\n/**\n * sort resources by startTime\n * @param filteredResources\n */\nexport function sortResources(filteredResources) {\n    return filteredResources.slice().sort(function (a, b) {\n        var valueA = a[PTN.FETCH_START];\n        var valueB = b[PTN.FETCH_START];\n        if (valueA > valueB) {\n            return 1;\n        }\n        else if (valueA < valueB) {\n            return -1;\n        }\n        return 0;\n    });\n}\n/**\n * Get closest performance resource ignoring the resources that have been\n * already used.\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n * @param initiatorType\n */\nexport function getResource(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {\n    if (ignoredResources === void 0) { ignoredResources = new WeakSet(); }\n    // de-relativize the URL before usage (does no harm to absolute URLs)\n    var urlNormalizingAnchor = getUrlNormalizingAnchor();\n    urlNormalizingAnchor.href = spanUrl;\n    spanUrl = urlNormalizingAnchor.href;\n    var filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);\n    if (filteredResources.length === 0) {\n        return {\n            mainRequest: undefined,\n        };\n    }\n    if (filteredResources.length === 1) {\n        return {\n            mainRequest: filteredResources[0],\n        };\n    }\n    var sorted = sortResources(filteredResources);\n    var parsedSpanUrl = parseUrl(spanUrl);\n    if (parsedSpanUrl.origin !== window.location.origin && sorted.length > 1) {\n        var corsPreFlightRequest = sorted[0];\n        var mainRequest = findMainRequest(sorted, corsPreFlightRequest[PTN.RESPONSE_END], endTimeHR);\n        var responseEnd = corsPreFlightRequest[PTN.RESPONSE_END];\n        var fetchStart = mainRequest[PTN.FETCH_START];\n        // no corsPreFlightRequest\n        if (fetchStart < responseEnd) {\n            mainRequest = corsPreFlightRequest;\n            corsPreFlightRequest = undefined;\n        }\n        return {\n            corsPreFlightRequest: corsPreFlightRequest,\n            mainRequest: mainRequest,\n        };\n    }\n    else {\n        return {\n            mainRequest: filteredResources[0],\n        };\n    }\n}\n/**\n * Will find the main request skipping the cors pre flight requests\n * @param resources\n * @param corsPreFlightRequestEndTime\n * @param spanEndTimeHR\n */\nfunction findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {\n    var spanEndTime = hrTimeToNanoseconds(spanEndTimeHR);\n    var minTime = hrTimeToNanoseconds(timeInputToHrTime(corsPreFlightRequestEndTime));\n    var mainRequest = resources[1];\n    var bestGap;\n    var length = resources.length;\n    for (var i = 1; i < length; i++) {\n        var resource = resources[i];\n        var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.FETCH_START]));\n        var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.RESPONSE_END]));\n        var currentGap = spanEndTime - resourceEndTime;\n        if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {\n            bestGap = currentGap;\n            mainRequest = resource;\n        }\n    }\n    return mainRequest;\n}\n/**\n * Filter all resources that has started and finished according to span start time and end time.\n *     It will return the closest resource to a start time\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n */\nfunction filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {\n    var startTime = hrTimeToNanoseconds(startTimeHR);\n    var endTime = hrTimeToNanoseconds(endTimeHR);\n    var filteredResources = resources.filter(function (resource) {\n        var resourceStartTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.FETCH_START]));\n        var resourceEndTime = hrTimeToNanoseconds(timeInputToHrTime(resource[PTN.RESPONSE_END]));\n        return (resource.initiatorType.toLowerCase() ===\n            (initiatorType || 'xmlhttprequest') &&\n            resource.name === spanUrl &&\n            resourceStartTime >= startTime &&\n            resourceEndTime <= endTime);\n    });\n    if (filteredResources.length > 0) {\n        filteredResources = filteredResources.filter(function (resource) {\n            return !ignoredResources.has(resource);\n        });\n    }\n    return filteredResources;\n}\n/**\n * Parses url using anchor element\n * @param url\n */\nexport function parseUrl(url) {\n    var a = document.createElement('a');\n    a.href = url;\n    return a;\n}\n/**\n * Get element XPath\n * @param target - target element\n * @param optimised - when id attribute of element is present the xpath can be\n * simplified to contain id\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getElementXPath(target, optimised) {\n    if (target.nodeType === Node.DOCUMENT_NODE) {\n        return '/';\n    }\n    var targetValue = getNodeValue(target, optimised);\n    if (optimised && targetValue.indexOf('@id') > 0) {\n        return targetValue;\n    }\n    var xpath = '';\n    if (target.parentNode) {\n        xpath += getElementXPath(target.parentNode, false);\n    }\n    xpath += targetValue;\n    return xpath;\n}\n/**\n * get node index within the siblings\n * @param target\n */\nfunction getNodeIndex(target) {\n    if (!target.parentNode) {\n        return 0;\n    }\n    var allowedTypes = [target.nodeType];\n    if (target.nodeType === Node.CDATA_SECTION_NODE) {\n        allowedTypes.push(Node.TEXT_NODE);\n    }\n    var elements = Array.from(target.parentNode.childNodes);\n    elements = elements.filter(function (element) {\n        var localName = element.localName;\n        return (allowedTypes.indexOf(element.nodeType) >= 0 &&\n            localName === target.localName);\n    });\n    if (elements.length >= 1) {\n        return elements.indexOf(target) + 1; // xpath starts from 1\n    }\n    // if there are no other similar child xpath doesn't need index\n    return 0;\n}\n/**\n * get node value for xpath\n * @param target\n * @param optimised\n */\nfunction getNodeValue(target, optimised) {\n    var nodeType = target.nodeType;\n    var index = getNodeIndex(target);\n    var nodeValue = '';\n    if (nodeType === Node.ELEMENT_NODE) {\n        var id = target.getAttribute('id');\n        if (optimised && id) {\n            return \"//*[@id=\\\"\" + id + \"\\\"]\";\n        }\n        nodeValue = target.localName;\n    }\n    else if (nodeType === Node.TEXT_NODE ||\n        nodeType === Node.CDATA_SECTION_NODE) {\n        nodeValue = 'text()';\n    }\n    else if (nodeType === Node.COMMENT_NODE) {\n        nodeValue = 'comment()';\n    }\n    else {\n        return '';\n    }\n    // if index is 1 it can be omitted in xpath\n    if (nodeValue && index > 1) {\n        return \"/\" + nodeValue + \"[\" + index + \"]\";\n    }\n    return \"/\" + nodeValue;\n}\n/**\n * Checks if trace headers should be propagated\n * @param spanUrl\n * @private\n */\nexport function shouldPropagateTraceHeaders(spanUrl, propagateTraceHeaderCorsUrls) {\n    var propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];\n    if (typeof propagateTraceHeaderUrls === 'string' ||\n        propagateTraceHeaderUrls instanceof RegExp) {\n        propagateTraceHeaderUrls = [propagateTraceHeaderUrls];\n    }\n    var parsedSpanUrl = parseUrl(spanUrl);\n    if (parsedSpanUrl.origin === window.location.origin) {\n        return true;\n    }\n    else {\n        return propagateTraceHeaderUrls.some(function (propagateTraceHeaderUrl) {\n            return urlMatches(spanUrl, propagateTraceHeaderUrl);\n        });\n    }\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}