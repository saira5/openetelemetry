{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar _a;\n\nimport { SpanKind } from '@opentelemetry/api';\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nexport var opentelemetryProto;\n\n(function (opentelemetryProto) {\n  var metrics;\n\n  (function (metrics) {\n    var v1;\n\n    (function (v1) {\n      var AggregationTemporality;\n\n      (function (AggregationTemporality) {\n        // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_UNSPECIFIED\"] = 0] = \"AGGREGATION_TEMPORALITY_UNSPECIFIED\"; // DELTA is an AggregationTemporality for a metric aggregator which reports\n        // changes since last report time. Successive metrics contain aggregation of\n        // values from continuous and non-overlapping intervals.\n        //\n        // The values for a DELTA metric are based only on the time interval\n        // associated with one measurement cycle. There is no dependency on\n        // previous measurements like is the case for CUMULATIVE metrics.\n        //\n        // For example, consider a system measuring the number of requests that\n        // it receives and reports the sum of these requests every second as a\n        // DELTA metric:\n        //\n        //   1. The system starts receiving at time=t_0.\n        //   2. A request is received, the system measures 1 request.\n        //   3. A request is received, the system measures 1 request.\n        //   4. A request is received, the system measures 1 request.\n        //   5. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+1 with a value of 3.\n        //   6. A request is received, the system measures 1 request.\n        //   7. A request is received, the system measures 1 request.\n        //   8. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0+1 to\n        //      t_0+2 with a value of 2.\n\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_DELTA\"] = 1] = \"AGGREGATION_TEMPORALITY_DELTA\"; // CUMULATIVE is an AggregationTemporality for a metric aggregator which\n        // reports changes since a fixed start time. This means that current values\n        // of a CUMULATIVE metric depend on all previous measurements since the\n        // start time. Because of this, the sender is required to retain this state\n        // in some form. If this state is lost or invalidated, the CUMULATIVE metric\n        // values MUST be reset and a new fixed start time following the last\n        // reported measurement time sent MUST be used.\n        //\n        // For example, consider a system measuring the number of requests that\n        // it receives and reports the sum of these requests every second as a\n        // CUMULATIVE metric:\n        //\n        //   1. The system starts receiving at time=t_0.\n        //   2. A request is received, the system measures 1 request.\n        //   3. A request is received, the system measures 1 request.\n        //   4. A request is received, the system measures 1 request.\n        //   5. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+1 with a value of 3.\n        //   6. A request is received, the system measures 1 request.\n        //   7. A request is received, the system measures 1 request.\n        //   8. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+2 with a value of 5.\n        //   9. The system experiences a fault and loses state.\n        //   10. The system recovers and resumes receiving at time=t_1.\n        //   11. A request is received, the system measures 1 request.\n        //   12. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_1 to\n        //      t_0+1 with a value of 1.\n        //\n        // Note: Even though, when reporting changes since last report time, using\n        // CUMULATIVE is valid, it is not recommended. This may cause problems for\n        // systems that do not use start_time to determine when the aggregation\n        // value was reset (e.g. Prometheus).\n\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_CUMULATIVE\"] = 2] = \"AGGREGATION_TEMPORALITY_CUMULATIVE\";\n      })(AggregationTemporality = v1.AggregationTemporality || (v1.AggregationTemporality = {}));\n    })(v1 = metrics.v1 || (metrics.v1 = {}));\n  })(metrics = opentelemetryProto.metrics || (opentelemetryProto.metrics = {}));\n\n  var trace;\n\n  (function (trace) {\n    var v1;\n\n    (function (v1) {\n      var ConstantSampler;\n\n      (function (ConstantSampler) {\n        var ConstantDecision;\n\n        (function (ConstantDecision) {\n          ConstantDecision[ConstantDecision[\"ALWAYS_OFF\"] = 0] = \"ALWAYS_OFF\";\n          ConstantDecision[ConstantDecision[\"ALWAYS_ON\"] = 1] = \"ALWAYS_ON\";\n          ConstantDecision[ConstantDecision[\"ALWAYS_PARENT\"] = 2] = \"ALWAYS_PARENT\";\n        })(ConstantDecision = ConstantSampler.ConstantDecision || (ConstantSampler.ConstantDecision = {}));\n      })(ConstantSampler = v1.ConstantSampler || (v1.ConstantSampler = {}));\n\n      var Span;\n\n      (function (Span) {\n        var SpanKind;\n\n        (function (SpanKind) {\n          SpanKind[SpanKind[\"SPAN_KIND_UNSPECIFIED\"] = 0] = \"SPAN_KIND_UNSPECIFIED\";\n          SpanKind[SpanKind[\"SPAN_KIND_INTERNAL\"] = 1] = \"SPAN_KIND_INTERNAL\";\n          SpanKind[SpanKind[\"SPAN_KIND_SERVER\"] = 2] = \"SPAN_KIND_SERVER\";\n          SpanKind[SpanKind[\"SPAN_KIND_CLIENT\"] = 3] = \"SPAN_KIND_CLIENT\";\n          SpanKind[SpanKind[\"SPAN_KIND_PRODUCER\"] = 4] = \"SPAN_KIND_PRODUCER\";\n          SpanKind[SpanKind[\"SPAN_KIND_CONSUMER\"] = 5] = \"SPAN_KIND_CONSUMER\";\n        })(SpanKind = Span.SpanKind || (Span.SpanKind = {}));\n      })(Span = v1.Span || (v1.Span = {}));\n    })(v1 = trace.v1 || (trace.v1 = {}));\n  })(trace = opentelemetryProto.trace || (opentelemetryProto.trace = {}));\n\n  var common;\n\n  (function (common) {\n    var v1;\n\n    (function (v1) {\n      var ValueType;\n\n      (function (ValueType) {\n        ValueType[ValueType[\"STRING\"] = 0] = \"STRING\";\n        ValueType[ValueType[\"INT\"] = 1] = \"INT\";\n        ValueType[ValueType[\"DOUBLE\"] = 2] = \"DOUBLE\";\n        ValueType[ValueType[\"BOOL\"] = 3] = \"BOOL\";\n      })(ValueType = v1.ValueType || (v1.ValueType = {}));\n    })(v1 = common.v1 || (common.v1 = {}));\n  })(common = opentelemetryProto.common || (opentelemetryProto.common = {}));\n})(opentelemetryProto || (opentelemetryProto = {}));\n/**\n * Interface for handling error\n */\n\n\nvar CollectorExporterError =\n/** @class */\nfunction (_super) {\n  __extends(CollectorExporterError, _super);\n\n  function CollectorExporterError(message, code, data) {\n    var _this = _super.call(this, message) || this;\n\n    _this.name = 'CollectorExporterError';\n    _this.data = data;\n    _this.code = code;\n    return _this;\n  }\n\n  return CollectorExporterError;\n}(Error);\n\nexport { CollectorExporterError };\n/**\n * Mapping between api SpanKind and proto SpanKind\n */\n\nexport var COLLECTOR_SPAN_KIND_MAPPING = (_a = {}, _a[SpanKind.INTERNAL] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_INTERNAL, _a[SpanKind.SERVER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_SERVER, _a[SpanKind.CLIENT] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CLIENT, _a[SpanKind.PRODUCER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_PRODUCER, _a[SpanKind.CONSUMER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CONSUMER, _a);","map":{"version":3,"sources":["../../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a;\nimport { SpanKind } from '@opentelemetry/api';\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nexport var opentelemetryProto;\n(function (opentelemetryProto) {\n    var metrics;\n    (function (metrics) {\n        var v1;\n        (function (v1) {\n            var AggregationTemporality;\n            (function (AggregationTemporality) {\n                // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n                AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_UNSPECIFIED\"] = 0] = \"AGGREGATION_TEMPORALITY_UNSPECIFIED\";\n                // DELTA is an AggregationTemporality for a metric aggregator which reports\n                // changes since last report time. Successive metrics contain aggregation of\n                // values from continuous and non-overlapping intervals.\n                //\n                // The values for a DELTA metric are based only on the time interval\n                // associated with one measurement cycle. There is no dependency on\n                // previous measurements like is the case for CUMULATIVE metrics.\n                //\n                // For example, consider a system measuring the number of requests that\n                // it receives and reports the sum of these requests every second as a\n                // DELTA metric:\n                //\n                //   1. The system starts receiving at time=t_0.\n                //   2. A request is received, the system measures 1 request.\n                //   3. A request is received, the system measures 1 request.\n                //   4. A request is received, the system measures 1 request.\n                //   5. The 1 second collection cycle ends. A metric is exported for the\n                //      number of requests received over the interval of time t_0 to\n                //      t_0+1 with a value of 3.\n                //   6. A request is received, the system measures 1 request.\n                //   7. A request is received, the system measures 1 request.\n                //   8. The 1 second collection cycle ends. A metric is exported for the\n                //      number of requests received over the interval of time t_0+1 to\n                //      t_0+2 with a value of 2.\n                AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_DELTA\"] = 1] = \"AGGREGATION_TEMPORALITY_DELTA\";\n                // CUMULATIVE is an AggregationTemporality for a metric aggregator which\n                // reports changes since a fixed start time. This means that current values\n                // of a CUMULATIVE metric depend on all previous measurements since the\n                // start time. Because of this, the sender is required to retain this state\n                // in some form. If this state is lost or invalidated, the CUMULATIVE metric\n                // values MUST be reset and a new fixed start time following the last\n                // reported measurement time sent MUST be used.\n                //\n                // For example, consider a system measuring the number of requests that\n                // it receives and reports the sum of these requests every second as a\n                // CUMULATIVE metric:\n                //\n                //   1. The system starts receiving at time=t_0.\n                //   2. A request is received, the system measures 1 request.\n                //   3. A request is received, the system measures 1 request.\n                //   4. A request is received, the system measures 1 request.\n                //   5. The 1 second collection cycle ends. A metric is exported for the\n                //      number of requests received over the interval of time t_0 to\n                //      t_0+1 with a value of 3.\n                //   6. A request is received, the system measures 1 request.\n                //   7. A request is received, the system measures 1 request.\n                //   8. The 1 second collection cycle ends. A metric is exported for the\n                //      number of requests received over the interval of time t_0 to\n                //      t_0+2 with a value of 5.\n                //   9. The system experiences a fault and loses state.\n                //   10. The system recovers and resumes receiving at time=t_1.\n                //   11. A request is received, the system measures 1 request.\n                //   12. The 1 second collection cycle ends. A metric is exported for the\n                //      number of requests received over the interval of time t_1 to\n                //      t_0+1 with a value of 1.\n                //\n                // Note: Even though, when reporting changes since last report time, using\n                // CUMULATIVE is valid, it is not recommended. This may cause problems for\n                // systems that do not use start_time to determine when the aggregation\n                // value was reset (e.g. Prometheus).\n                AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_CUMULATIVE\"] = 2] = \"AGGREGATION_TEMPORALITY_CUMULATIVE\";\n            })(AggregationTemporality = v1.AggregationTemporality || (v1.AggregationTemporality = {}));\n        })(v1 = metrics.v1 || (metrics.v1 = {}));\n    })(metrics = opentelemetryProto.metrics || (opentelemetryProto.metrics = {}));\n    var trace;\n    (function (trace) {\n        var v1;\n        (function (v1) {\n            var ConstantSampler;\n            (function (ConstantSampler) {\n                var ConstantDecision;\n                (function (ConstantDecision) {\n                    ConstantDecision[ConstantDecision[\"ALWAYS_OFF\"] = 0] = \"ALWAYS_OFF\";\n                    ConstantDecision[ConstantDecision[\"ALWAYS_ON\"] = 1] = \"ALWAYS_ON\";\n                    ConstantDecision[ConstantDecision[\"ALWAYS_PARENT\"] = 2] = \"ALWAYS_PARENT\";\n                })(ConstantDecision = ConstantSampler.ConstantDecision || (ConstantSampler.ConstantDecision = {}));\n            })(ConstantSampler = v1.ConstantSampler || (v1.ConstantSampler = {}));\n            var Span;\n            (function (Span) {\n                var SpanKind;\n                (function (SpanKind) {\n                    SpanKind[SpanKind[\"SPAN_KIND_UNSPECIFIED\"] = 0] = \"SPAN_KIND_UNSPECIFIED\";\n                    SpanKind[SpanKind[\"SPAN_KIND_INTERNAL\"] = 1] = \"SPAN_KIND_INTERNAL\";\n                    SpanKind[SpanKind[\"SPAN_KIND_SERVER\"] = 2] = \"SPAN_KIND_SERVER\";\n                    SpanKind[SpanKind[\"SPAN_KIND_CLIENT\"] = 3] = \"SPAN_KIND_CLIENT\";\n                    SpanKind[SpanKind[\"SPAN_KIND_PRODUCER\"] = 4] = \"SPAN_KIND_PRODUCER\";\n                    SpanKind[SpanKind[\"SPAN_KIND_CONSUMER\"] = 5] = \"SPAN_KIND_CONSUMER\";\n                })(SpanKind = Span.SpanKind || (Span.SpanKind = {}));\n            })(Span = v1.Span || (v1.Span = {}));\n        })(v1 = trace.v1 || (trace.v1 = {}));\n    })(trace = opentelemetryProto.trace || (opentelemetryProto.trace = {}));\n    var common;\n    (function (common) {\n        var v1;\n        (function (v1) {\n            var ValueType;\n            (function (ValueType) {\n                ValueType[ValueType[\"STRING\"] = 0] = \"STRING\";\n                ValueType[ValueType[\"INT\"] = 1] = \"INT\";\n                ValueType[ValueType[\"DOUBLE\"] = 2] = \"DOUBLE\";\n                ValueType[ValueType[\"BOOL\"] = 3] = \"BOOL\";\n            })(ValueType = v1.ValueType || (v1.ValueType = {}));\n        })(v1 = common.v1 || (common.v1 = {}));\n    })(common = opentelemetryProto.common || (opentelemetryProto.common = {}));\n})(opentelemetryProto || (opentelemetryProto = {}));\n/**\n * Interface for handling error\n */\nvar CollectorExporterError = /** @class */ (function (_super) {\n    __extends(CollectorExporterError, _super);\n    function CollectorExporterError(message, code, data) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'CollectorExporterError';\n        _this.data = data;\n        _this.code = code;\n        return _this;\n    }\n    return CollectorExporterError;\n}(Error));\nexport { CollectorExporterError };\n/**\n * Mapping between api SpanKind and proto SpanKind\n */\nexport var COLLECTOR_SPAN_KIND_MAPPING = (_a = {},\n    _a[SpanKind.INTERNAL] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_INTERNAL,\n    _a[SpanKind.SERVER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_SERVER,\n    _a[SpanKind.CLIENT] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CLIENT,\n    _a[SpanKind.PRODUCER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_PRODUCER,\n    _a[SpanKind.CONSUMER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CONSUMER,\n    _a);\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}