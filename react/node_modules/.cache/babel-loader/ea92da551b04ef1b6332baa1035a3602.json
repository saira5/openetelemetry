{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { diag } from '@opentelemetry/api';\nimport * as api from '@opentelemetry/api-metrics';\n/**\n * This class represent the base to BoundInstrument, which is responsible for generating\n * the TimeSeries.\n */\n\nvar BaseBoundInstrument =\n/** @class */\nfunction () {\n  function BaseBoundInstrument(labels, _disabled, _valueType, _aggregator) {\n    this._disabled = _disabled;\n    this._valueType = _valueType;\n    this._aggregator = _aggregator;\n    this._labels = labels;\n  }\n\n  BaseBoundInstrument.prototype.update = function (value) {\n    if (this._disabled) return;\n\n    if (typeof value !== 'number') {\n      diag.error(\"Metric cannot accept a non-number value for \" + Object.values(this._labels) + \".\");\n      return;\n    }\n\n    if (this._valueType === api.ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\"INT value type cannot accept a floating-point value for \" + Object.values(this._labels) + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n    }\n\n    this._aggregator.update(value);\n  };\n\n  BaseBoundInstrument.prototype.getLabels = function () {\n    return this._labels;\n  };\n\n  BaseBoundInstrument.prototype.getAggregator = function () {\n    return this._aggregator;\n  };\n\n  return BaseBoundInstrument;\n}();\n\nexport { BaseBoundInstrument };\n/**\n * BoundCounter allows the SDK to observe/record a single metric event. The\n * value of single instrument in the `Counter` associated with specified Labels.\n */\n\nvar BoundCounter =\n/** @class */\nfunction (_super) {\n  __extends(BoundCounter, _super);\n\n  function BoundCounter(labels, disabled, valueType, aggregator) {\n    return _super.call(this, labels, disabled, valueType, aggregator) || this;\n  }\n\n  BoundCounter.prototype.add = function (value) {\n    if (value < 0) {\n      diag.error(\"Counter cannot descend for \" + Object.values(this._labels));\n      return;\n    }\n\n    this.update(value);\n  };\n\n  return BoundCounter;\n}(BaseBoundInstrument);\n\nexport { BoundCounter };\n/**\n * BoundUpDownCounter allows the SDK to observe/record a single metric event.\n * The value of single instrument in the `UpDownCounter` associated with\n * specified Labels.\n */\n\nvar BoundUpDownCounter =\n/** @class */\nfunction (_super) {\n  __extends(BoundUpDownCounter, _super);\n\n  function BoundUpDownCounter(labels, disabled, valueType, aggregator) {\n    return _super.call(this, labels, disabled, valueType, aggregator) || this;\n  }\n\n  BoundUpDownCounter.prototype.add = function (value) {\n    this.update(value);\n  };\n\n  return BoundUpDownCounter;\n}(BaseBoundInstrument);\n\nexport { BoundUpDownCounter };\n/**\n * BoundMeasure is an implementation of the {@link BoundMeasure} interface.\n */\n\nvar BoundValueRecorder =\n/** @class */\nfunction (_super) {\n  __extends(BoundValueRecorder, _super);\n\n  function BoundValueRecorder(labels, disabled, valueType, aggregator) {\n    return _super.call(this, labels, disabled, valueType, aggregator) || this;\n  }\n\n  BoundValueRecorder.prototype.record = function (value) {\n    this.update(value);\n  };\n\n  return BoundValueRecorder;\n}(BaseBoundInstrument);\n\nexport { BoundValueRecorder };\n/**\n * BoundObserver is an implementation of the {@link BoundObserver} interface.\n */\n\nvar BoundObserver =\n/** @class */\nfunction (_super) {\n  __extends(BoundObserver, _super);\n\n  function BoundObserver(labels, disabled, valueType, aggregator) {\n    return _super.call(this, labels, disabled, valueType, aggregator) || this;\n  }\n\n  return BoundObserver;\n}(BaseBoundInstrument);\n\nexport { BoundObserver };","map":{"version":3,"sources":["../../src/BoundInstrument.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { diag } from '@opentelemetry/api';\nimport * as api from '@opentelemetry/api-metrics';\n/**\n * This class represent the base to BoundInstrument, which is responsible for generating\n * the TimeSeries.\n */\nvar BaseBoundInstrument = /** @class */ (function () {\n    function BaseBoundInstrument(labels, _disabled, _valueType, _aggregator) {\n        this._disabled = _disabled;\n        this._valueType = _valueType;\n        this._aggregator = _aggregator;\n        this._labels = labels;\n    }\n    BaseBoundInstrument.prototype.update = function (value) {\n        if (this._disabled)\n            return;\n        if (typeof value !== 'number') {\n            diag.error(\"Metric cannot accept a non-number value for \" + Object.values(this._labels) + \".\");\n            return;\n        }\n        if (this._valueType === api.ValueType.INT && !Number.isInteger(value)) {\n            diag.warn(\"INT value type cannot accept a floating-point value for \" + Object.values(this._labels) + \", ignoring the fractional digits.\");\n            value = Math.trunc(value);\n        }\n        this._aggregator.update(value);\n    };\n    BaseBoundInstrument.prototype.getLabels = function () {\n        return this._labels;\n    };\n    BaseBoundInstrument.prototype.getAggregator = function () {\n        return this._aggregator;\n    };\n    return BaseBoundInstrument;\n}());\nexport { BaseBoundInstrument };\n/**\n * BoundCounter allows the SDK to observe/record a single metric event. The\n * value of single instrument in the `Counter` associated with specified Labels.\n */\nvar BoundCounter = /** @class */ (function (_super) {\n    __extends(BoundCounter, _super);\n    function BoundCounter(labels, disabled, valueType, aggregator) {\n        return _super.call(this, labels, disabled, valueType, aggregator) || this;\n    }\n    BoundCounter.prototype.add = function (value) {\n        if (value < 0) {\n            diag.error(\"Counter cannot descend for \" + Object.values(this._labels));\n            return;\n        }\n        this.update(value);\n    };\n    return BoundCounter;\n}(BaseBoundInstrument));\nexport { BoundCounter };\n/**\n * BoundUpDownCounter allows the SDK to observe/record a single metric event.\n * The value of single instrument in the `UpDownCounter` associated with\n * specified Labels.\n */\nvar BoundUpDownCounter = /** @class */ (function (_super) {\n    __extends(BoundUpDownCounter, _super);\n    function BoundUpDownCounter(labels, disabled, valueType, aggregator) {\n        return _super.call(this, labels, disabled, valueType, aggregator) || this;\n    }\n    BoundUpDownCounter.prototype.add = function (value) {\n        this.update(value);\n    };\n    return BoundUpDownCounter;\n}(BaseBoundInstrument));\nexport { BoundUpDownCounter };\n/**\n * BoundMeasure is an implementation of the {@link BoundMeasure} interface.\n */\nvar BoundValueRecorder = /** @class */ (function (_super) {\n    __extends(BoundValueRecorder, _super);\n    function BoundValueRecorder(labels, disabled, valueType, aggregator) {\n        return _super.call(this, labels, disabled, valueType, aggregator) || this;\n    }\n    BoundValueRecorder.prototype.record = function (value) {\n        this.update(value);\n    };\n    return BoundValueRecorder;\n}(BaseBoundInstrument));\nexport { BoundValueRecorder };\n/**\n * BoundObserver is an implementation of the {@link BoundObserver} interface.\n */\nvar BoundObserver = /** @class */ (function (_super) {\n    __extends(BoundObserver, _super);\n    function BoundObserver(labels, disabled, valueType, aggregator) {\n        return _super.call(this, labels, disabled, valueType, aggregator) || this;\n    }\n    return BoundObserver;\n}(BaseBoundInstrument));\nexport { BoundObserver };\n//# sourceMappingURL=BoundInstrument.js.map"]},"metadata":{},"sourceType":"module"}