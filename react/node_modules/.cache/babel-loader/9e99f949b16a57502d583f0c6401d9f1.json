{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api-metrics';\nimport * as core from '@opentelemetry/core';\nimport { AggregatorKind, MetricKind } from '@opentelemetry/sdk-metrics-base';\nimport { toCollectorResource } from './transform';\nimport { opentelemetryProto } from './types';\n/**\n * Converts labels\n * @param labels\n */\n\nexport function toCollectorLabels(labels) {\n  return Object.entries(labels).map(function (_a) {\n    var key = _a[0],\n        value = _a[1];\n    return {\n      key: key,\n      value: String(value)\n    };\n  });\n}\n/**\n * Given a MetricDescriptor, return its temporality in a compatible format with the collector\n * @param descriptor\n */\n\nexport function toAggregationTemporality(metric) {\n  if (metric.descriptor.metricKind === MetricKind.VALUE_OBSERVER) {\n    return opentelemetryProto.metrics.v1.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED;\n  }\n\n  return metric.aggregationTemporality;\n}\n/**\n * Returns an DataPoint which can have integers or doublle values\n * @param metric\n * @param startTime\n */\n\nexport function toDataPoint(metric, startTime) {\n  return {\n    labels: toCollectorLabels(metric.labels),\n    value: metric.aggregator.toPoint().value,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(metric.aggregator.toPoint().timestamp)\n  };\n}\n/**\n * Returns a HistogramPoint to the collector\n * @param metric\n * @param startTime\n */\n\nexport function toHistogramPoint(metric, startTime) {\n  var _a = metric.aggregator.toPoint(),\n      value = _a.value,\n      timestamp = _a.timestamp;\n\n  return {\n    labels: toCollectorLabels(metric.labels),\n    sum: value.sum,\n    count: value.count,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(timestamp),\n    bucketCounts: value.buckets.counts,\n    explicitBounds: value.buckets.boundaries\n  };\n}\n/**\n * Converts a metric to be compatible with the collector\n * @param metric\n * @param startTime start time in nanoseconds\n */\n\nexport function toCollectorMetric(metric, startTime) {\n  var metricCollector = {\n    name: metric.descriptor.name,\n    description: metric.descriptor.description,\n    unit: metric.descriptor.unit\n  };\n\n  if (metric.aggregator.kind === AggregatorKind.SUM || metric.descriptor.metricKind === MetricKind.SUM_OBSERVER || metric.descriptor.metricKind === MetricKind.UP_DOWN_SUM_OBSERVER) {\n    var result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n      isMonotonic: metric.descriptor.metricKind === MetricKind.COUNTER || metric.descriptor.metricKind === MetricKind.SUM_OBSERVER,\n      aggregationTemporality: toAggregationTemporality(metric)\n    };\n\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intSum = result;\n    } else {\n      metricCollector.doubleSum = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.LAST_VALUE) {\n    var result = {\n      dataPoints: [toDataPoint(metric, startTime)]\n    };\n\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intGauge = result;\n    } else {\n      metricCollector.doubleGauge = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.HISTOGRAM) {\n    var result = {\n      dataPoints: [toHistogramPoint(metric, startTime)],\n      aggregationTemporality: toAggregationTemporality(metric)\n    };\n\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intHistogram = result;\n    } else {\n      metricCollector.doubleHistogram = result;\n    }\n  }\n\n  return metricCollector;\n}\n/**\n * Prepares metric service request to be sent to collector\n * @param metrics metrics\n * @param startTime start time of the metric in nanoseconds\n * @param collectorMetricExporterBase\n */\n\nexport function toCollectorExportMetricServiceRequest(metrics, startTime, collectorExporterBase) {\n  var groupedMetrics = groupMetricsByResourceAndLibrary(metrics);\n  var additionalAttributes = Object.assign({}, collectorExporterBase.attributes);\n  return {\n    resourceMetrics: toCollectorResourceMetrics(groupedMetrics, additionalAttributes, startTime)\n  };\n}\n/**\n * Takes an array of metrics and groups them by resource and instrumentation\n * library\n * @param metrics metrics\n */\n\nexport function groupMetricsByResourceAndLibrary(metrics) {\n  return metrics.reduce(function (metricMap, metric) {\n    //group by resource\n    var resourceMetrics = metricMap.get(metric.resource);\n\n    if (!resourceMetrics) {\n      resourceMetrics = new Map();\n      metricMap.set(metric.resource, resourceMetrics);\n    } //group by instrumentation library\n\n\n    var libMetrics = resourceMetrics.get(metric.instrumentationLibrary);\n\n    if (!libMetrics) {\n      libMetrics = new Array();\n      resourceMetrics.set(metric.instrumentationLibrary, libMetrics);\n    }\n\n    libMetrics.push(metric);\n    return metricMap;\n  }, new Map());\n}\n/**\n * Convert to InstrumentationLibraryMetrics\n * @param instrumentationLibrary\n * @param metrics\n * @param startTime\n */\n\nfunction toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime) {\n  return {\n    metrics: metrics.map(function (metric) {\n      return toCollectorMetric(metric, startTime);\n    }),\n    instrumentationLibrary: instrumentationLibrary\n  };\n}\n/**\n * Returns a list of resource metrics which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n */\n\n\nfunction toCollectorResourceMetrics(groupedMetrics, baseAttributes, startTime) {\n  return Array.from(groupedMetrics, function (_a) {\n    var resource = _a[0],\n        libMetrics = _a[1];\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibraryMetrics: Array.from(libMetrics, function (_a) {\n        var instrumentationLibrary = _a[0],\n            metrics = _a[1];\n        return toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime);\n      })\n    };\n  });\n}","map":{"version":3,"sources":["../../src/transformMetrics.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api-metrics';\nimport * as core from '@opentelemetry/core';\nimport { AggregatorKind, MetricKind, } from '@opentelemetry/sdk-metrics-base';\nimport { toCollectorResource } from './transform';\nimport { opentelemetryProto } from './types';\n/**\n * Converts labels\n * @param labels\n */\nexport function toCollectorLabels(labels) {\n    return Object.entries(labels).map(function (_a) {\n        var key = _a[0], value = _a[1];\n        return { key: key, value: String(value) };\n    });\n}\n/**\n * Given a MetricDescriptor, return its temporality in a compatible format with the collector\n * @param descriptor\n */\nexport function toAggregationTemporality(metric) {\n    if (metric.descriptor.metricKind === MetricKind.VALUE_OBSERVER) {\n        return opentelemetryProto.metrics.v1.AggregationTemporality\n            .AGGREGATION_TEMPORALITY_UNSPECIFIED;\n    }\n    return metric.aggregationTemporality;\n}\n/**\n * Returns an DataPoint which can have integers or doublle values\n * @param metric\n * @param startTime\n */\nexport function toDataPoint(metric, startTime) {\n    return {\n        labels: toCollectorLabels(metric.labels),\n        value: metric.aggregator.toPoint().value,\n        startTimeUnixNano: startTime,\n        timeUnixNano: core.hrTimeToNanoseconds(metric.aggregator.toPoint().timestamp),\n    };\n}\n/**\n * Returns a HistogramPoint to the collector\n * @param metric\n * @param startTime\n */\nexport function toHistogramPoint(metric, startTime) {\n    var _a = metric.aggregator.toPoint(), value = _a.value, timestamp = _a.timestamp;\n    return {\n        labels: toCollectorLabels(metric.labels),\n        sum: value.sum,\n        count: value.count,\n        startTimeUnixNano: startTime,\n        timeUnixNano: core.hrTimeToNanoseconds(timestamp),\n        bucketCounts: value.buckets.counts,\n        explicitBounds: value.buckets.boundaries,\n    };\n}\n/**\n * Converts a metric to be compatible with the collector\n * @param metric\n * @param startTime start time in nanoseconds\n */\nexport function toCollectorMetric(metric, startTime) {\n    var metricCollector = {\n        name: metric.descriptor.name,\n        description: metric.descriptor.description,\n        unit: metric.descriptor.unit,\n    };\n    if (metric.aggregator.kind === AggregatorKind.SUM ||\n        metric.descriptor.metricKind === MetricKind.SUM_OBSERVER ||\n        metric.descriptor.metricKind === MetricKind.UP_DOWN_SUM_OBSERVER) {\n        var result = {\n            dataPoints: [toDataPoint(metric, startTime)],\n            isMonotonic: metric.descriptor.metricKind === MetricKind.COUNTER ||\n                metric.descriptor.metricKind === MetricKind.SUM_OBSERVER,\n            aggregationTemporality: toAggregationTemporality(metric),\n        };\n        if (metric.descriptor.valueType === ValueType.INT) {\n            metricCollector.intSum = result;\n        }\n        else {\n            metricCollector.doubleSum = result;\n        }\n    }\n    else if (metric.aggregator.kind === AggregatorKind.LAST_VALUE) {\n        var result = {\n            dataPoints: [toDataPoint(metric, startTime)],\n        };\n        if (metric.descriptor.valueType === ValueType.INT) {\n            metricCollector.intGauge = result;\n        }\n        else {\n            metricCollector.doubleGauge = result;\n        }\n    }\n    else if (metric.aggregator.kind === AggregatorKind.HISTOGRAM) {\n        var result = {\n            dataPoints: [toHistogramPoint(metric, startTime)],\n            aggregationTemporality: toAggregationTemporality(metric),\n        };\n        if (metric.descriptor.valueType === ValueType.INT) {\n            metricCollector.intHistogram = result;\n        }\n        else {\n            metricCollector.doubleHistogram = result;\n        }\n    }\n    return metricCollector;\n}\n/**\n * Prepares metric service request to be sent to collector\n * @param metrics metrics\n * @param startTime start time of the metric in nanoseconds\n * @param collectorMetricExporterBase\n */\nexport function toCollectorExportMetricServiceRequest(metrics, startTime, collectorExporterBase) {\n    var groupedMetrics = groupMetricsByResourceAndLibrary(metrics);\n    var additionalAttributes = Object.assign({}, collectorExporterBase.attributes);\n    return {\n        resourceMetrics: toCollectorResourceMetrics(groupedMetrics, additionalAttributes, startTime),\n    };\n}\n/**\n * Takes an array of metrics and groups them by resource and instrumentation\n * library\n * @param metrics metrics\n */\nexport function groupMetricsByResourceAndLibrary(metrics) {\n    return metrics.reduce(function (metricMap, metric) {\n        //group by resource\n        var resourceMetrics = metricMap.get(metric.resource);\n        if (!resourceMetrics) {\n            resourceMetrics = new Map();\n            metricMap.set(metric.resource, resourceMetrics);\n        }\n        //group by instrumentation library\n        var libMetrics = resourceMetrics.get(metric.instrumentationLibrary);\n        if (!libMetrics) {\n            libMetrics = new Array();\n            resourceMetrics.set(metric.instrumentationLibrary, libMetrics);\n        }\n        libMetrics.push(metric);\n        return metricMap;\n    }, new Map());\n}\n/**\n * Convert to InstrumentationLibraryMetrics\n * @param instrumentationLibrary\n * @param metrics\n * @param startTime\n */\nfunction toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime) {\n    return {\n        metrics: metrics.map(function (metric) { return toCollectorMetric(metric, startTime); }),\n        instrumentationLibrary: instrumentationLibrary,\n    };\n}\n/**\n * Returns a list of resource metrics which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n */\nfunction toCollectorResourceMetrics(groupedMetrics, baseAttributes, startTime) {\n    return Array.from(groupedMetrics, function (_a) {\n        var resource = _a[0], libMetrics = _a[1];\n        return {\n            resource: toCollectorResource(resource, baseAttributes),\n            instrumentationLibraryMetrics: Array.from(libMetrics, function (_a) {\n                var instrumentationLibrary = _a[0], metrics = _a[1];\n                return toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime);\n            }),\n        };\n    });\n}\n//# sourceMappingURL=transformMetrics.js.map"]},"metadata":{},"sourceType":"module"}