{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, TraceFlags } from '@opentelemetry/api';\nimport { ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\n\nvar BatchSpanProcessorBase =\n/** @class */\nfunction () {\n  function BatchSpanProcessorBase(_exporter, config) {\n    this._exporter = _exporter;\n    this._finishedSpans = [];\n    this._isShutdown = false;\n    this._shuttingDownPromise = Promise.resolve();\n    var env = getEnv();\n    this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number' ? config.maxExportBatchSize : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number' ? config.maxQueueSize : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number' ? config.scheduledDelayMillis : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number' ? config.exportTimeoutMillis : env.OTEL_BSP_EXPORT_TIMEOUT;\n  }\n\n  BatchSpanProcessorBase.prototype.forceFlush = function () {\n    if (this._isShutdown) {\n      return this._shuttingDownPromise;\n    }\n\n    return this._flushAll();\n  }; // does nothing.\n\n\n  BatchSpanProcessorBase.prototype.onStart = function (_span) {};\n\n  BatchSpanProcessorBase.prototype.onEnd = function (span) {\n    if (this._isShutdown) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  };\n\n  BatchSpanProcessorBase.prototype.shutdown = function () {\n    var _this = this;\n\n    if (this._isShutdown) {\n      return this._shuttingDownPromise;\n    }\n\n    this._isShutdown = true;\n    this._shuttingDownPromise = new Promise(function (resolve, reject) {\n      Promise.resolve().then(function () {\n        return _this.onShutdown();\n      }).then(function () {\n        return _this._flushAll();\n      }).then(function () {\n        return _this._exporter.shutdown();\n      }).then(resolve).catch(function (e) {\n        reject(e);\n      });\n    });\n    return this._shuttingDownPromise;\n  };\n  /** Add a span in the buffer. */\n\n\n  BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n      return;\n    }\n\n    this._finishedSpans.push(span);\n\n    this._maybeStartTimer();\n  };\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n\n\n  BatchSpanProcessorBase.prototype._flushAll = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var promises = []; // calculate number of batches\n\n      var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n\n      for (var i = 0, j = count; i < j; i++) {\n        promises.push(_this._flushOneBatch());\n      }\n\n      Promise.all(promises).then(function () {\n        resolve();\n      }).catch(reject);\n    });\n  };\n\n  BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n\n    return new Promise(function (resolve, reject) {\n      var timer = setTimeout(function () {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, _this._exportTimeoutMillis); // prevent downstream exporter calls from generating spans\n\n      context.with(suppressTracing(context.active()), function () {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside of the execution of this callback.\n        _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function (result) {\n          var _a;\n\n          clearTimeout(timer);\n\n          if (result.code === ExportResultCode.SUCCESS) {\n            resolve();\n          } else {\n            reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n          }\n        });\n      });\n    });\n  };\n\n  BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n    var _this = this;\n\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(function () {\n      _this._flushOneBatch().then(function () {\n        if (_this._finishedSpans.length > 0) {\n          _this._clearTimer();\n\n          _this._maybeStartTimer();\n        }\n      }).catch(function (e) {\n        globalErrorHandler(e);\n      });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  };\n\n  BatchSpanProcessorBase.prototype._clearTimer = function () {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  };\n\n  return BatchSpanProcessorBase;\n}();\n\nexport { BatchSpanProcessorBase };","map":{"version":3,"sources":["../../../src/export/BatchSpanProcessorBase.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { context, TraceFlags } from '@opentelemetry/api';\nimport { ExportResultCode, getEnv, globalErrorHandler, suppressTracing, unrefTimer, } from '@opentelemetry/core';\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nvar BatchSpanProcessorBase = /** @class */ (function () {\n    function BatchSpanProcessorBase(_exporter, config) {\n        this._exporter = _exporter;\n        this._finishedSpans = [];\n        this._isShutdown = false;\n        this._shuttingDownPromise = Promise.resolve();\n        var env = getEnv();\n        this._maxExportBatchSize =\n            typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === 'number'\n                ? config.maxExportBatchSize\n                : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n        this._maxQueueSize =\n            typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === 'number'\n                ? config.maxQueueSize\n                : env.OTEL_BSP_MAX_QUEUE_SIZE;\n        this._scheduledDelayMillis =\n            typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === 'number'\n                ? config.scheduledDelayMillis\n                : env.OTEL_BSP_SCHEDULE_DELAY;\n        this._exportTimeoutMillis =\n            typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === 'number'\n                ? config.exportTimeoutMillis\n                : env.OTEL_BSP_EXPORT_TIMEOUT;\n    }\n    BatchSpanProcessorBase.prototype.forceFlush = function () {\n        if (this._isShutdown) {\n            return this._shuttingDownPromise;\n        }\n        return this._flushAll();\n    };\n    // does nothing.\n    BatchSpanProcessorBase.prototype.onStart = function (_span) { };\n    BatchSpanProcessorBase.prototype.onEnd = function (span) {\n        if (this._isShutdown) {\n            return;\n        }\n        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n            return;\n        }\n        this._addToBuffer(span);\n    };\n    BatchSpanProcessorBase.prototype.shutdown = function () {\n        var _this = this;\n        if (this._isShutdown) {\n            return this._shuttingDownPromise;\n        }\n        this._isShutdown = true;\n        this._shuttingDownPromise = new Promise(function (resolve, reject) {\n            Promise.resolve()\n                .then(function () {\n                return _this.onShutdown();\n            })\n                .then(function () {\n                return _this._flushAll();\n            })\n                .then(function () {\n                return _this._exporter.shutdown();\n            })\n                .then(resolve)\n                .catch(function (e) {\n                reject(e);\n            });\n        });\n        return this._shuttingDownPromise;\n    };\n    /** Add a span in the buffer. */\n    BatchSpanProcessorBase.prototype._addToBuffer = function (span) {\n        if (this._finishedSpans.length >= this._maxQueueSize) {\n            // limit reached, drop span\n            return;\n        }\n        this._finishedSpans.push(span);\n        this._maybeStartTimer();\n    };\n    /**\n     * Send all spans to the exporter respecting the batch size limit\n     * This function is used only on forceFlush or shutdown,\n     * for all other cases _flush should be used\n     * */\n    BatchSpanProcessorBase.prototype._flushAll = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var promises = [];\n            // calculate number of batches\n            var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);\n            for (var i = 0, j = count; i < j; i++) {\n                promises.push(_this._flushOneBatch());\n            }\n            Promise.all(promises)\n                .then(function () {\n                resolve();\n            })\n                .catch(reject);\n        });\n    };\n    BatchSpanProcessorBase.prototype._flushOneBatch = function () {\n        var _this = this;\n        this._clearTimer();\n        if (this._finishedSpans.length === 0) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve, reject) {\n            var timer = setTimeout(function () {\n                // don't wait anymore for export, this way the next batch can start\n                reject(new Error('Timeout'));\n            }, _this._exportTimeoutMillis);\n            // prevent downstream exporter calls from generating spans\n            context.with(suppressTracing(context.active()), function () {\n                // Reset the finished spans buffer here because the next invocations of the _flush method\n                // could pass the same finished spans to the exporter if the buffer is cleared\n                // outside of the execution of this callback.\n                _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function (result) {\n                    var _a;\n                    clearTimeout(timer);\n                    if (result.code === ExportResultCode.SUCCESS) {\n                        resolve();\n                    }\n                    else {\n                        reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error('BatchSpanProcessor: span export failed'));\n                    }\n                });\n            });\n        });\n    };\n    BatchSpanProcessorBase.prototype._maybeStartTimer = function () {\n        var _this = this;\n        if (this._timer !== undefined)\n            return;\n        this._timer = setTimeout(function () {\n            _this._flushOneBatch()\n                .then(function () {\n                if (_this._finishedSpans.length > 0) {\n                    _this._clearTimer();\n                    _this._maybeStartTimer();\n                }\n            })\n                .catch(function (e) {\n                globalErrorHandler(e);\n            });\n        }, this._scheduledDelayMillis);\n        unrefTimer(this._timer);\n    };\n    BatchSpanProcessorBase.prototype._clearTimer = function () {\n        if (this._timer !== undefined) {\n            clearTimeout(this._timer);\n            this._timer = undefined;\n        }\n    };\n    return BatchSpanProcessorBase;\n}());\nexport { BatchSpanProcessorBase };\n//# sourceMappingURL=BatchSpanProcessorBase.js.map"]},"metadata":{},"sourceType":"module"}