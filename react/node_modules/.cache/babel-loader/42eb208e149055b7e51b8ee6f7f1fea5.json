{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as aggregators from './aggregators';\nimport { MetricKind } from './types';\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\n\nvar Processor =\n/** @class */\nfunction () {\n  function Processor() {\n    this._batchMap = new Map();\n  }\n\n  Processor.prototype.checkPointSet = function () {\n    return Array.from(this._batchMap.values());\n  };\n\n  return Processor;\n}();\n\nexport { Processor };\n/**\n * Processor which retains all dimensions/labels. It accepts all records and\n * passes them for exporting.\n */\n\nvar UngroupedProcessor =\n/** @class */\nfunction (_super) {\n  __extends(UngroupedProcessor, _super);\n\n  function UngroupedProcessor() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  UngroupedProcessor.prototype.aggregatorFor = function (metricDescriptor) {\n    switch (metricDescriptor.metricKind) {\n      case MetricKind.COUNTER:\n      case MetricKind.UP_DOWN_COUNTER:\n        return new aggregators.SumAggregator();\n\n      case MetricKind.SUM_OBSERVER:\n      case MetricKind.UP_DOWN_SUM_OBSERVER:\n      case MetricKind.VALUE_OBSERVER:\n        return new aggregators.LastValueAggregator();\n\n      case MetricKind.VALUE_RECORDER:\n        return new aggregators.HistogramAggregator(metricDescriptor.boundaries || [Infinity]);\n\n      default:\n        return new aggregators.LastValueAggregator();\n    }\n  };\n\n  UngroupedProcessor.prototype.process = function (record) {\n    var labels = Object.keys(record.labels).map(function (k) {\n      return k + \"=\" + record.labels[k];\n    }).join(',');\n\n    this._batchMap.set(record.descriptor.name + labels, record);\n  };\n\n  return UngroupedProcessor;\n}(Processor);\n\nexport { UngroupedProcessor };","map":{"version":3,"sources":["../../../src/export/Processor.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,OAAO,KAAK,WAAZ,MAA6B,eAA7B;AACA,SAEE,UAFF,QAKO,SALP;AAOA;;;;;;AAMG;;AACH,IAAA,SAAA;AAAA;AAAA,YAAA;EAAA,SAAA,SAAA,GAAA;IACqB,KAAA,SAAA,GAAY,IAAI,GAAJ,EAAZ;EAWpB;;EAHC,SAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;IACE,OAAO,KAAK,CAAC,IAAN,CAAW,KAAK,SAAL,CAAe,MAAf,EAAX,CAAP;EACD,CAFD;;EAGF,OAAA,SAAA;AAAC,CAZD,EAAA;;;AAcA;;;AAGG;;AACH,IAAA,kBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;EAAwC,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;EAAxC,SAAA,kBAAA,GAAA;;EA4BC;;EA3BC,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,gBAAd,EAAgD;IAC9C,QAAQ,gBAAgB,CAAC,UAAzB;MACE,KAAK,UAAU,CAAC,OAAhB;MACA,KAAK,UAAU,CAAC,eAAhB;QACE,OAAO,IAAI,WAAW,CAAC,aAAhB,EAAP;;MAEF,KAAK,UAAU,CAAC,YAAhB;MACA,KAAK,UAAU,CAAC,oBAAhB;MACA,KAAK,UAAU,CAAC,cAAhB;QACE,OAAO,IAAI,WAAW,CAAC,mBAAhB,EAAP;;MAEF,KAAK,UAAU,CAAC,cAAhB;QACE,OAAO,IAAI,WAAW,CAAC,mBAAhB,CACL,gBAAgB,CAAC,UAAjB,IAA+B,CAAC,QAAD,CAD1B,CAAP;;MAIF;QACE,OAAO,IAAI,WAAW,CAAC,mBAAhB,EAAP;IAhBJ;EAkBD,CAnBD;;EAqBA,kBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,MAAR,EAA4B;IAC1B,IAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,MAAnB,EACZ,GADY,CACR,UAAA,CAAA,EAAC;MAAI,OAAG,CAAC,GAAA,GAAD,GAAK,MAAM,CAAC,MAAP,CAAR,CAAQ,CAAR;IAA0B,CADvB,EAEZ,IAFY,CAEP,GAFO,CAAf;;IAGA,KAAK,SAAL,CAAe,GAAf,CAAmB,MAAM,CAAC,UAAP,CAAkB,IAAlB,GAAyB,MAA5C,EAAoD,MAApD;EACD,CALD;;EAMF,OAAA,kBAAA;AAAC,CA5BD,CAAwC,SAAxC,CAAA","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport * as aggregators from './aggregators';\nimport { MetricKind, } from './types';\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\nvar Processor = /** @class */ (function () {\n    function Processor() {\n        this._batchMap = new Map();\n    }\n    Processor.prototype.checkPointSet = function () {\n        return Array.from(this._batchMap.values());\n    };\n    return Processor;\n}());\nexport { Processor };\n/**\n * Processor which retains all dimensions/labels. It accepts all records and\n * passes them for exporting.\n */\nvar UngroupedProcessor = /** @class */ (function (_super) {\n    __extends(UngroupedProcessor, _super);\n    function UngroupedProcessor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    UngroupedProcessor.prototype.aggregatorFor = function (metricDescriptor) {\n        switch (metricDescriptor.metricKind) {\n            case MetricKind.COUNTER:\n            case MetricKind.UP_DOWN_COUNTER:\n                return new aggregators.SumAggregator();\n            case MetricKind.SUM_OBSERVER:\n            case MetricKind.UP_DOWN_SUM_OBSERVER:\n            case MetricKind.VALUE_OBSERVER:\n                return new aggregators.LastValueAggregator();\n            case MetricKind.VALUE_RECORDER:\n                return new aggregators.HistogramAggregator(metricDescriptor.boundaries || [Infinity]);\n            default:\n                return new aggregators.LastValueAggregator();\n        }\n    };\n    UngroupedProcessor.prototype.process = function (record) {\n        var labels = Object.keys(record.labels)\n            .map(function (k) { return k + \"=\" + record.labels[k]; })\n            .join(',');\n        this._batchMap.set(record.descriptor.name + labels, record);\n    };\n    return UngroupedProcessor;\n}(Processor));\nexport { UngroupedProcessor };\n//# sourceMappingURL=Processor.js.map"]},"metadata":{},"sourceType":"module"}