{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as core from '@opentelemetry/core';\nimport { COLLECTOR_SPAN_KIND_MAPPING, opentelemetryProto } from './types';\nvar MAX_INTEGER_VALUE = 2147483647;\nvar MIN_INTEGER_VALUE = -2147483648;\n/**\n * Converts attributes to KeyValue array\n * @param attributes\n */\n\nexport function toCollectorAttributes(attributes) {\n  return Object.keys(attributes).map(function (key) {\n    return toCollectorAttributeKeyValue(key, attributes[key]);\n  });\n}\n/**\n * Converts array of unknown value to ArrayValue\n * @param values\n */\n\nexport function toCollectorArrayValue(values) {\n  return {\n    values: values.map(function (value) {\n      return toCollectorAnyValue(value);\n    })\n  };\n}\n/**\n * Converts attributes to KeyValueList\n * @param attributes\n */\n\nexport function toCollectorKeyValueList(attributes) {\n  return {\n    values: toCollectorAttributes(attributes)\n  };\n}\n/**\n * Converts key and unknown value to KeyValue\n * @param value event value\n */\n\nexport function toCollectorAttributeKeyValue(key, value) {\n  var anyValue = toCollectorAnyValue(value);\n  return {\n    key: key,\n    value: anyValue\n  };\n}\n/**\n * Converts unknown value to AnyValue\n * @param value\n */\n\nexport function toCollectorAnyValue(value) {\n  var anyValue = {};\n\n  if (typeof value === 'string') {\n    anyValue.stringValue = value;\n  } else if (typeof value === 'boolean') {\n    anyValue.boolValue = value;\n  } else if (typeof value === 'number' && value <= MAX_INTEGER_VALUE && value >= MIN_INTEGER_VALUE && Number.isInteger(value)) {\n    anyValue.intValue = value;\n  } else if (typeof value === 'number') {\n    anyValue.doubleValue = value;\n  } else if (Array.isArray(value)) {\n    anyValue.arrayValue = toCollectorArrayValue(value);\n  } else if (value) {\n    anyValue.kvlistValue = toCollectorKeyValueList(value);\n  }\n\n  return anyValue;\n}\n/**\n *\n * Converts events\n * @param events array of events\n */\n\nexport function toCollectorEvents(timedEvents) {\n  return timedEvents.map(function (timedEvent) {\n    var timeUnixNano = core.hrTimeToNanoseconds(timedEvent.time);\n    var name = timedEvent.name;\n    var attributes = toCollectorAttributes(timedEvent.attributes || {});\n    var droppedAttributesCount = 0;\n    var protoEvent = {\n      timeUnixNano: timeUnixNano,\n      name: name,\n      attributes: attributes,\n      droppedAttributesCount: droppedAttributesCount\n    };\n    return protoEvent;\n  });\n}\n/**\n * Converts links\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nfunction toCollectorLinks(span, useHex) {\n  return span.links.map(function (link) {\n    var protoLink = {\n      traceId: useHex ? link.context.traceId : core.hexToBase64(link.context.traceId),\n      spanId: useHex ? link.context.spanId : core.hexToBase64(link.context.spanId),\n      attributes: toCollectorAttributes(link.attributes || {}),\n      droppedAttributesCount: 0\n    };\n    return protoLink;\n  });\n}\n/**\n * Converts span\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\n\nexport function toCollectorSpan(span, useHex) {\n  return {\n    traceId: useHex ? span.spanContext().traceId : core.hexToBase64(span.spanContext().traceId),\n    spanId: useHex ? span.spanContext().spanId : core.hexToBase64(span.spanContext().spanId),\n    parentSpanId: span.parentSpanId ? useHex ? span.parentSpanId : core.hexToBase64(span.parentSpanId) : undefined,\n    traceState: toCollectorTraceState(span.spanContext().traceState),\n    name: span.name,\n    kind: toCollectorKind(span.kind),\n    startTimeUnixNano: core.hrTimeToNanoseconds(span.startTime),\n    endTimeUnixNano: core.hrTimeToNanoseconds(span.endTime),\n    attributes: toCollectorAttributes(span.attributes),\n    droppedAttributesCount: 0,\n    events: toCollectorEvents(span.events),\n    droppedEventsCount: 0,\n    status: toCollectorStatus(span.status),\n    links: toCollectorLinks(span, useHex),\n    droppedLinksCount: 0\n  };\n}\n/**\n * Converts status\n * @param status\n */\n\nexport function toCollectorStatus(status) {\n  var spanStatus = {\n    code: status.code\n  };\n\n  if (typeof status.message !== 'undefined') {\n    spanStatus.message = status.message;\n  }\n\n  return spanStatus;\n}\n/**\n * Converts resource\n * @param resource\n * @param additionalAttributes\n */\n\nexport function toCollectorResource(resource, additionalAttributes) {\n  if (additionalAttributes === void 0) {\n    additionalAttributes = {};\n  }\n\n  var attr = Object.assign({}, additionalAttributes, resource ? resource.attributes : {});\n  var resourceProto = {\n    attributes: toCollectorAttributes(attr),\n    droppedAttributesCount: 0\n  };\n  return resourceProto;\n}\n/**\n * Converts span kind\n * @param kind\n */\n\nexport function toCollectorKind(kind) {\n  var collectorKind = COLLECTOR_SPAN_KIND_MAPPING[kind];\n  return typeof collectorKind === 'number' ? collectorKind : opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_UNSPECIFIED;\n}\n/**\n * Converts traceState\n * @param traceState\n */\n\nexport function toCollectorTraceState(traceState) {\n  if (!traceState) return undefined;\n  return traceState.serialize();\n}\n/**\n * Prepares trace service request to be sent to collector\n * @param spans spans\n * @param collectorExporterBase\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nexport function toCollectorExportTraceServiceRequest(spans, collectorTraceExporterBase, useHex) {\n  var groupedSpans = groupSpansByResourceAndLibrary(spans);\n  var additionalAttributes = Object.assign({}, collectorTraceExporterBase.attributes);\n  return {\n    resourceSpans: toCollectorResourceSpans(groupedSpans, additionalAttributes, useHex)\n  };\n}\n/**\n * Takes an array of spans and groups them by resource and instrumentation\n * library\n * @param spans spans\n */\n\nexport function groupSpansByResourceAndLibrary(spans) {\n  return spans.reduce(function (spanMap, span) {\n    //group by resource\n    var resourceSpans = spanMap.get(span.resource);\n\n    if (!resourceSpans) {\n      resourceSpans = new Map();\n      spanMap.set(span.resource, resourceSpans);\n    } //group by instrumentation library\n\n\n    var libSpans = resourceSpans.get(span.instrumentationLibrary);\n\n    if (!libSpans) {\n      libSpans = new Array();\n      resourceSpans.set(span.instrumentationLibrary, libSpans);\n    }\n\n    libSpans.push(span);\n    return spanMap;\n  }, new Map());\n}\n/**\n * Convert to InstrumentationLibrarySpans\n * @param instrumentationLibrary\n * @param spans\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nfunction toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex) {\n  return {\n    spans: spans.map(function (span) {\n      return toCollectorSpan(span, useHex);\n    }),\n    instrumentationLibrary: instrumentationLibrary\n  };\n}\n/**\n * Returns a list of resource spans which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\n\nfunction toCollectorResourceSpans(groupedSpans, baseAttributes, useHex) {\n  return Array.from(groupedSpans, function (_a) {\n    var resource = _a[0],\n        libSpans = _a[1];\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibrarySpans: Array.from(libSpans, function (_a) {\n        var instrumentationLibrary = _a[0],\n            spans = _a[1];\n        return toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex);\n      })\n    };\n  });\n}","map":{"version":3,"sources":["../../src/transform.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as core from '@opentelemetry/core';\nimport { COLLECTOR_SPAN_KIND_MAPPING, opentelemetryProto, } from './types';\nvar MAX_INTEGER_VALUE = 2147483647;\nvar MIN_INTEGER_VALUE = -2147483648;\n/**\n * Converts attributes to KeyValue array\n * @param attributes\n */\nexport function toCollectorAttributes(attributes) {\n    return Object.keys(attributes).map(function (key) {\n        return toCollectorAttributeKeyValue(key, attributes[key]);\n    });\n}\n/**\n * Converts array of unknown value to ArrayValue\n * @param values\n */\nexport function toCollectorArrayValue(values) {\n    return {\n        values: values.map(function (value) { return toCollectorAnyValue(value); }),\n    };\n}\n/**\n * Converts attributes to KeyValueList\n * @param attributes\n */\nexport function toCollectorKeyValueList(attributes) {\n    return {\n        values: toCollectorAttributes(attributes),\n    };\n}\n/**\n * Converts key and unknown value to KeyValue\n * @param value event value\n */\nexport function toCollectorAttributeKeyValue(key, value) {\n    var anyValue = toCollectorAnyValue(value);\n    return {\n        key: key,\n        value: anyValue,\n    };\n}\n/**\n * Converts unknown value to AnyValue\n * @param value\n */\nexport function toCollectorAnyValue(value) {\n    var anyValue = {};\n    if (typeof value === 'string') {\n        anyValue.stringValue = value;\n    }\n    else if (typeof value === 'boolean') {\n        anyValue.boolValue = value;\n    }\n    else if (typeof value === 'number' &&\n        value <= MAX_INTEGER_VALUE &&\n        value >= MIN_INTEGER_VALUE &&\n        Number.isInteger(value)) {\n        anyValue.intValue = value;\n    }\n    else if (typeof value === 'number') {\n        anyValue.doubleValue = value;\n    }\n    else if (Array.isArray(value)) {\n        anyValue.arrayValue = toCollectorArrayValue(value);\n    }\n    else if (value) {\n        anyValue.kvlistValue = toCollectorKeyValueList(value);\n    }\n    return anyValue;\n}\n/**\n *\n * Converts events\n * @param events array of events\n */\nexport function toCollectorEvents(timedEvents) {\n    return timedEvents.map(function (timedEvent) {\n        var timeUnixNano = core.hrTimeToNanoseconds(timedEvent.time);\n        var name = timedEvent.name;\n        var attributes = toCollectorAttributes(timedEvent.attributes || {});\n        var droppedAttributesCount = 0;\n        var protoEvent = {\n            timeUnixNano: timeUnixNano,\n            name: name,\n            attributes: attributes,\n            droppedAttributesCount: droppedAttributesCount,\n        };\n        return protoEvent;\n    });\n}\n/**\n * Converts links\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorLinks(span, useHex) {\n    return span.links.map(function (link) {\n        var protoLink = {\n            traceId: useHex\n                ? link.context.traceId\n                : core.hexToBase64(link.context.traceId),\n            spanId: useHex\n                ? link.context.spanId\n                : core.hexToBase64(link.context.spanId),\n            attributes: toCollectorAttributes(link.attributes || {}),\n            droppedAttributesCount: 0,\n        };\n        return protoLink;\n    });\n}\n/**\n * Converts span\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toCollectorSpan(span, useHex) {\n    return {\n        traceId: useHex\n            ? span.spanContext().traceId\n            : core.hexToBase64(span.spanContext().traceId),\n        spanId: useHex\n            ? span.spanContext().spanId\n            : core.hexToBase64(span.spanContext().spanId),\n        parentSpanId: span.parentSpanId\n            ? useHex\n                ? span.parentSpanId\n                : core.hexToBase64(span.parentSpanId)\n            : undefined,\n        traceState: toCollectorTraceState(span.spanContext().traceState),\n        name: span.name,\n        kind: toCollectorKind(span.kind),\n        startTimeUnixNano: core.hrTimeToNanoseconds(span.startTime),\n        endTimeUnixNano: core.hrTimeToNanoseconds(span.endTime),\n        attributes: toCollectorAttributes(span.attributes),\n        droppedAttributesCount: 0,\n        events: toCollectorEvents(span.events),\n        droppedEventsCount: 0,\n        status: toCollectorStatus(span.status),\n        links: toCollectorLinks(span, useHex),\n        droppedLinksCount: 0,\n    };\n}\n/**\n * Converts status\n * @param status\n */\nexport function toCollectorStatus(status) {\n    var spanStatus = {\n        code: status.code,\n    };\n    if (typeof status.message !== 'undefined') {\n        spanStatus.message = status.message;\n    }\n    return spanStatus;\n}\n/**\n * Converts resource\n * @param resource\n * @param additionalAttributes\n */\nexport function toCollectorResource(resource, additionalAttributes) {\n    if (additionalAttributes === void 0) { additionalAttributes = {}; }\n    var attr = Object.assign({}, additionalAttributes, resource ? resource.attributes : {});\n    var resourceProto = {\n        attributes: toCollectorAttributes(attr),\n        droppedAttributesCount: 0,\n    };\n    return resourceProto;\n}\n/**\n * Converts span kind\n * @param kind\n */\nexport function toCollectorKind(kind) {\n    var collectorKind = COLLECTOR_SPAN_KIND_MAPPING[kind];\n    return typeof collectorKind === 'number'\n        ? collectorKind\n        : opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_UNSPECIFIED;\n}\n/**\n * Converts traceState\n * @param traceState\n */\nexport function toCollectorTraceState(traceState) {\n    if (!traceState)\n        return undefined;\n    return traceState.serialize();\n}\n/**\n * Prepares trace service request to be sent to collector\n * @param spans spans\n * @param collectorExporterBase\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toCollectorExportTraceServiceRequest(spans, collectorTraceExporterBase, useHex) {\n    var groupedSpans = groupSpansByResourceAndLibrary(spans);\n    var additionalAttributes = Object.assign({}, collectorTraceExporterBase.attributes);\n    return {\n        resourceSpans: toCollectorResourceSpans(groupedSpans, additionalAttributes, useHex),\n    };\n}\n/**\n * Takes an array of spans and groups them by resource and instrumentation\n * library\n * @param spans spans\n */\nexport function groupSpansByResourceAndLibrary(spans) {\n    return spans.reduce(function (spanMap, span) {\n        //group by resource\n        var resourceSpans = spanMap.get(span.resource);\n        if (!resourceSpans) {\n            resourceSpans = new Map();\n            spanMap.set(span.resource, resourceSpans);\n        }\n        //group by instrumentation library\n        var libSpans = resourceSpans.get(span.instrumentationLibrary);\n        if (!libSpans) {\n            libSpans = new Array();\n            resourceSpans.set(span.instrumentationLibrary, libSpans);\n        }\n        libSpans.push(span);\n        return spanMap;\n    }, new Map());\n}\n/**\n * Convert to InstrumentationLibrarySpans\n * @param instrumentationLibrary\n * @param spans\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex) {\n    return {\n        spans: spans.map(function (span) { return toCollectorSpan(span, useHex); }),\n        instrumentationLibrary: instrumentationLibrary,\n    };\n}\n/**\n * Returns a list of resource spans which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorResourceSpans(groupedSpans, baseAttributes, useHex) {\n    return Array.from(groupedSpans, function (_a) {\n        var resource = _a[0], libSpans = _a[1];\n        return {\n            resource: toCollectorResource(resource, baseAttributes),\n            instrumentationLibrarySpans: Array.from(libSpans, function (_a) {\n                var instrumentationLibrary = _a[0], spans = _a[1];\n                return toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex);\n            }),\n        };\n    });\n}\n//# sourceMappingURL=transform.js.map"]},"metadata":{},"sourceType":"module"}