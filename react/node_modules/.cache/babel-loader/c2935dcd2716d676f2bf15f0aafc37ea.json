{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Implementation of api BatchObserverResult\n */\nvar BatchObserverResult =\n/** @class */\nfunction () {\n  function BatchObserverResult() {\n    /**\n     * Cancels the further updates.\n     * This is used to prevent updating the value of result that took too\n     * long to update. For example to avoid update after timeout.\n     * See {@link BatchObserver.collect}\n     */\n    this.cancelled = false;\n  }\n  /**\n   * used to save a callback that will be called after the observations are\n   *     updated\n   * @param [callback]\n   */\n\n\n  BatchObserverResult.prototype.onObserveCalled = function (callback) {\n    this._callback = callback;\n  };\n\n  BatchObserverResult.prototype.observe = function (labels, observations) {\n    var _this = this;\n\n    if (this.cancelled || !this._callback) {\n      return;\n    }\n\n    observations.forEach(function (observation) {\n      observation.observer.bind(labels).update(observation.value);\n    });\n\n    if (!this._immediate) {\n      this._immediate = setImmediate(function () {\n        if (typeof _this._callback === 'function') {\n          _this._callback(); // prevent user from updating the values later if for any reason\n          // the observerBatchResult will be referenced and then try to use\n\n\n          _this._callback = undefined;\n        }\n      });\n    }\n  };\n\n  return BatchObserverResult;\n}();\n\nexport { BatchObserverResult };","map":{"version":3,"sources":["../../src/BatchObserverResult.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAIH;;AAEG;AACH,IAAA,mBAAA;AAAA;AAAA,YAAA;EAAA,SAAA,mBAAA,GAAA;IAGE;;;;;AAKG;IACH,KAAA,SAAA,GAAY,KAAZ;EA6BD;EA3BC;;;;AAIG;;;EACH,mBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,QAAhB,EAAqC;IACnC,KAAK,SAAL,GAAiB,QAAjB;EACD,CAFD;;EAIA,mBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,MAAR,EAA4B,YAA5B,EAA2D;IAA3D,IAAA,KAAA,GAAA,IAAA;;IACE,IAAI,KAAK,SAAL,IAAkB,CAAC,KAAK,SAA5B,EAAuC;MACrC;IACD;;IACD,YAAY,CAAC,OAAb,CAAqB,UAAA,WAAA,EAAW;MAC9B,WAAW,CAAC,QAAZ,CAAqB,IAArB,CAA0B,MAA1B,EAAkC,MAAlC,CAAyC,WAAW,CAAC,KAArD;IACD,CAFD;;IAGA,IAAI,CAAC,KAAK,UAAV,EAAsB;MACpB,KAAK,UAAL,GAAkB,YAAY,CAAC,YAAA;QAC7B,IAAI,OAAO,KAAI,CAAC,SAAZ,KAA0B,UAA9B,EAA0C;UACxC,KAAI,CAAC,SAAL,GADwC,CAExC;UACA;;;UACA,KAAI,CAAC,SAAL,GAAiB,SAAjB;QACD;MACF,CAP6B,CAA9B;IAQD;EACF,CAjBD;;EAkBF,OAAA,mBAAA;AAAC,CAtCD,EAAA","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Implementation of api BatchObserverResult\n */\nvar BatchObserverResult = /** @class */ (function () {\n    function BatchObserverResult() {\n        /**\n         * Cancels the further updates.\n         * This is used to prevent updating the value of result that took too\n         * long to update. For example to avoid update after timeout.\n         * See {@link BatchObserver.collect}\n         */\n        this.cancelled = false;\n    }\n    /**\n     * used to save a callback that will be called after the observations are\n     *     updated\n     * @param [callback]\n     */\n    BatchObserverResult.prototype.onObserveCalled = function (callback) {\n        this._callback = callback;\n    };\n    BatchObserverResult.prototype.observe = function (labels, observations) {\n        var _this = this;\n        if (this.cancelled || !this._callback) {\n            return;\n        }\n        observations.forEach(function (observation) {\n            observation.observer.bind(labels).update(observation.value);\n        });\n        if (!this._immediate) {\n            this._immediate = setImmediate(function () {\n                if (typeof _this._callback === 'function') {\n                    _this._callback();\n                    // prevent user from updating the values later if for any reason\n                    // the observerBatchResult will be referenced and then try to use\n                    _this._callback = undefined;\n                }\n            });\n        }\n    };\n    return BatchObserverResult;\n}());\nexport { BatchObserverResult };\n//# sourceMappingURL=BatchObserverResult.js.map"]},"metadata":{},"sourceType":"module"}