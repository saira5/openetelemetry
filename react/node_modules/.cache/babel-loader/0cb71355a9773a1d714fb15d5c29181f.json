{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport { DiagLogLevel } from '../diag/types';\nimport { getGlobal, registerGlobal, unregisterGlobal } from '../internal/global-utils';\nvar API_NAME = 'diag';\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\n\nvar DiagAPI =\n/** @class */\nfunction () {\n  /**\n   * Private internal constructor\n   * @private\n   */\n  function DiagAPI() {\n    function _logProxy(funcName) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var logger = getGlobal('diag'); // shortcut if logger not set\n\n        if (!logger) return;\n        return logger[funcName].apply(logger, args);\n      };\n    } // Using self local variable for minification purposes as 'this' cannot be minified\n\n\n    var self = this; // DiagAPI specific functions\n\n    self.setLogger = function (logger, logLevel) {\n      var _a, _b;\n\n      if (logLevel === void 0) {\n        logLevel = DiagLogLevel.INFO;\n      }\n\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');\n        self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);\n        return false;\n      }\n\n      var oldLogger = getGlobal('diag');\n      var newLogger = createLogLevelDiagLogger(logLevel, logger); // There already is an logger registered. We'll let it know before overwriting it.\n\n      if (oldLogger) {\n        var stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<failed to generate stacktrace>';\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.disable = function () {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = function (options) {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n  /** Get the singleton instance of the DiagAPI API */\n\n\n  DiagAPI.instance = function () {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  };\n\n  return DiagAPI;\n}();\n\nexport { DiagAPI };","map":{"version":3,"sources":["../../../src/api/diag.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    self.setLogger = (\n      logger: DiagLogger,\n      logLevel: DiagLogLevel = DiagLogLevel.INFO\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(logLevel, logger);\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - [Optional] The DiagLogger instance to set as the default logger.\n   * @param logLevel - [Optional] The DiagLogLevel used to filter logs sent to the logger. If not provided it will default to INFO.\n   * @returns true if the logger was successfully registered, else false\n   */\n  public setLogger!: (logger: DiagLogger, logLevel?: DiagLogLevel) => boolean;\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}