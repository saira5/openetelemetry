{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\nexport var TRACE_PARENT_HEADER = 'traceparent';\nexport var TRACE_STATE_HEADER = 'tracestate';\nvar VERSION = '00';\nvar VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nvar TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nvar PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nvar FLAGS_PART = '[\\\\da-f]{2}';\nvar TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\n\nexport function parseTraceParent(traceParent) {\n  var match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null; // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n\n  if (match[1] === '00' && match[5]) return null;\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16)\n  };\n}\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\n\nvar HttpTraceContextPropagator =\n/** @class */\nfunction () {\n  function HttpTraceContextPropagator() {}\n\n  HttpTraceContextPropagator.prototype.inject = function (context, carrier, setter) {\n    var spanContext = trace.getSpanContext(context);\n    if (!spanContext || isTracingSuppressed(context) || !isSpanContextValid(spanContext)) return;\n    var traceParent = VERSION + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n\n    if (spanContext.traceState) {\n      setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n    }\n  };\n\n  HttpTraceContextPropagator.prototype.extract = function (context, carrier, getter) {\n    var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    var spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n    spanContext.isRemote = true;\n    var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(',') : traceStateHeader;\n      spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);\n    }\n\n    return trace.setSpanContext(context, spanContext);\n  };\n\n  HttpTraceContextPropagator.prototype.fields = function () {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  };\n\n  return HttpTraceContextPropagator;\n}();\n\nexport { HttpTraceContextPropagator };","map":{"version":3,"sources":["../../../src/trace/HttpTraceContextPropagator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, trace, TraceFlags, } from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\nexport var TRACE_PARENT_HEADER = 'traceparent';\nexport var TRACE_STATE_HEADER = 'tracestate';\nvar VERSION = '00';\nvar VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nvar TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nvar PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nvar FLAGS_PART = '[\\\\da-f]{2}';\nvar TRACE_PARENT_REGEX = new RegExp(\"^\\\\s?(\" + VERSION_PART + \")-(\" + TRACE_ID_PART + \")-(\" + PARENT_ID_PART + \")-(\" + FLAGS_PART + \")(-.*)?\\\\s?$\");\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent) {\n    var match = TRACE_PARENT_REGEX.exec(traceParent);\n    if (!match)\n        return null;\n    // According to the specification the implementation should be compatible\n    // with future versions. If there are more parts, we only reject it if it's using version 00\n    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n    if (match[1] === '00' && match[5])\n        return null;\n    return {\n        traceId: match[2],\n        spanId: match[3],\n        traceFlags: parseInt(match[4], 16),\n    };\n}\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nvar HttpTraceContextPropagator = /** @class */ (function () {\n    function HttpTraceContextPropagator() {\n    }\n    HttpTraceContextPropagator.prototype.inject = function (context, carrier, setter) {\n        var spanContext = trace.getSpanContext(context);\n        if (!spanContext ||\n            isTracingSuppressed(context) ||\n            !isSpanContextValid(spanContext))\n            return;\n        var traceParent = VERSION + \"-\" + spanContext.traceId + \"-\" + spanContext.spanId + \"-0\" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);\n        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n        if (spanContext.traceState) {\n            setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());\n        }\n    };\n    HttpTraceContextPropagator.prototype.extract = function (context, carrier, getter) {\n        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n        if (!traceParentHeader)\n            return context;\n        var traceParent = Array.isArray(traceParentHeader)\n            ? traceParentHeader[0]\n            : traceParentHeader;\n        if (typeof traceParent !== 'string')\n            return context;\n        var spanContext = parseTraceParent(traceParent);\n        if (!spanContext)\n            return context;\n        spanContext.isRemote = true;\n        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n        if (traceStateHeader) {\n            // If more than one `tracestate` header is found, we merge them into a\n            // single header.\n            var state = Array.isArray(traceStateHeader)\n                ? traceStateHeader.join(',')\n                : traceStateHeader;\n            spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);\n        }\n        return trace.setSpanContext(context, spanContext);\n    };\n    HttpTraceContextPropagator.prototype.fields = function () {\n        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n    };\n    return HttpTraceContextPropagator;\n}());\nexport { HttpTraceContextPropagator };\n//# sourceMappingURL=HttpTraceContextPropagator.js.map"]},"metadata":{},"sourceType":"module"}