{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { otperformance as performance } from '../platform';\nvar NANOSECOND_DIGITS = 9;\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number to HrTime\n * @param epochMillis\n */\n\nfunction numberToHrtime(epochMillis) {\n  var epochSeconds = epochMillis / 1000; // Decimals only.\n\n  var seconds = Math.trunc(epochSeconds); // Round sub-nanosecond accuracy to nanosecond.\n\n  var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) * SECOND_TO_NANOSECONDS;\n  return [seconds, nanos];\n}\n\nfunction getTimeOrigin() {\n  var timeOrigin = performance.timeOrigin;\n\n  if (typeof timeOrigin !== 'number') {\n    var perf = performance;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n\n  return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\n\n\nexport function hrTime(performanceNow) {\n  var timeOrigin = numberToHrtime(getTimeOrigin());\n  var now = numberToHrtime(typeof performanceNow === 'number' ? performanceNow : performance.now());\n  var seconds = timeOrigin[0] + now[0];\n  var nanos = timeOrigin[1] + now[1]; // Nanoseconds\n\n  if (nanos > SECOND_TO_NANOSECONDS) {\n    nanos -= SECOND_TO_NANOSECONDS;\n    seconds += 1;\n  }\n\n  return [seconds, nanos];\n}\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\n\nexport function timeInputToHrTime(time) {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return numberToHrtime(time);\n    }\n  } else if (time instanceof Date) {\n    return numberToHrtime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\n\nexport function hrTimeDuration(startTime, endTime) {\n  var seconds = endTime[0] - startTime[0];\n  var nanos = endTime[1] - startTime[1]; // overflow\n\n  if (nanos < 0) {\n    seconds -= 1; // negate\n\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n\n  return [seconds, nanos];\n}\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param hrTime\n */\n\nexport function hrTimeToTimeStamp(hrTime) {\n  var precision = NANOSECOND_DIGITS;\n  var tmp = \"\" + '0'.repeat(precision) + hrTime[1] + \"Z\";\n  var nanoString = tmp.substr(tmp.length - precision - 1);\n  var date = new Date(hrTime[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n/**\n * Convert hrTime to nanoseconds.\n * @param hrTime\n */\n\nexport function hrTimeToNanoseconds(hrTime) {\n  return hrTime[0] * SECOND_TO_NANOSECONDS + hrTime[1];\n}\n/**\n * Convert hrTime to milliseconds.\n * @param hrTime\n */\n\nexport function hrTimeToMilliseconds(hrTime) {\n  return Math.round(hrTime[0] * 1e3 + hrTime[1] / 1e6);\n}\n/**\n * Convert hrTime to microseconds.\n * @param hrTime\n */\n\nexport function hrTimeToMicroseconds(hrTime) {\n  return Math.round(hrTime[0] * 1e6 + hrTime[1] / 1e3);\n}\n/**\n * check if time is HrTime\n * @param value\n */\n\nexport function isTimeInputHrTime(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number';\n}\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\n\nexport function isTimeInput(value) {\n  return isTimeInputHrTime(value) || typeof value === 'number' || value instanceof Date;\n}","map":{"version":3,"sources":["../../../src/common/time.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { otperformance as performance } from '../platform';\nvar NANOSECOND_DIGITS = 9;\nvar SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n/**\n * Converts a number to HrTime\n * @param epochMillis\n */\nfunction numberToHrtime(epochMillis) {\n    var epochSeconds = epochMillis / 1000;\n    // Decimals only.\n    var seconds = Math.trunc(epochSeconds);\n    // Round sub-nanosecond accuracy to nanosecond.\n    var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) *\n        SECOND_TO_NANOSECONDS;\n    return [seconds, nanos];\n}\nfunction getTimeOrigin() {\n    var timeOrigin = performance.timeOrigin;\n    if (typeof timeOrigin !== 'number') {\n        var perf = performance;\n        timeOrigin = perf.timing && perf.timing.fetchStart;\n    }\n    return timeOrigin;\n}\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow) {\n    var timeOrigin = numberToHrtime(getTimeOrigin());\n    var now = numberToHrtime(typeof performanceNow === 'number' ? performanceNow : performance.now());\n    var seconds = timeOrigin[0] + now[0];\n    var nanos = timeOrigin[1] + now[1];\n    // Nanoseconds\n    if (nanos > SECOND_TO_NANOSECONDS) {\n        nanos -= SECOND_TO_NANOSECONDS;\n        seconds += 1;\n    }\n    return [seconds, nanos];\n}\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time) {\n    // process.hrtime\n    if (isTimeInputHrTime(time)) {\n        return time;\n    }\n    else if (typeof time === 'number') {\n        // Must be a performance.now() if it's smaller than process start time.\n        if (time < getTimeOrigin()) {\n            return hrTime(time);\n        }\n        else {\n            // epoch milliseconds or performance.timeOrigin\n            return numberToHrtime(time);\n        }\n    }\n    else if (time instanceof Date) {\n        return numberToHrtime(time.getTime());\n    }\n    else {\n        throw TypeError('Invalid input type');\n    }\n}\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(startTime, endTime) {\n    var seconds = endTime[0] - startTime[0];\n    var nanos = endTime[1] - startTime[1];\n    // overflow\n    if (nanos < 0) {\n        seconds -= 1;\n        // negate\n        nanos += SECOND_TO_NANOSECONDS;\n    }\n    return [seconds, nanos];\n}\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param hrTime\n */\nexport function hrTimeToTimeStamp(hrTime) {\n    var precision = NANOSECOND_DIGITS;\n    var tmp = \"\" + '0'.repeat(precision) + hrTime[1] + \"Z\";\n    var nanoString = tmp.substr(tmp.length - precision - 1);\n    var date = new Date(hrTime[0] * 1000).toISOString();\n    return date.replace('000Z', nanoString);\n}\n/**\n * Convert hrTime to nanoseconds.\n * @param hrTime\n */\nexport function hrTimeToNanoseconds(hrTime) {\n    return hrTime[0] * SECOND_TO_NANOSECONDS + hrTime[1];\n}\n/**\n * Convert hrTime to milliseconds.\n * @param hrTime\n */\nexport function hrTimeToMilliseconds(hrTime) {\n    return Math.round(hrTime[0] * 1e3 + hrTime[1] / 1e6);\n}\n/**\n * Convert hrTime to microseconds.\n * @param hrTime\n */\nexport function hrTimeToMicroseconds(hrTime) {\n    return Math.round(hrTime[0] * 1e6 + hrTime[1] / 1e3);\n}\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value) {\n    return (Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'number' &&\n        typeof value[1] === 'number');\n}\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(value) {\n    return (isTimeInputHrTime(value) ||\n        typeof value === 'number' ||\n        value instanceof Date);\n}\n//# sourceMappingURL=time.js.map"]},"metadata":{},"sourceType":"module"}